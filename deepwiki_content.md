

# Source: https://deepwiki.com/lijiaxu2021/MagicWord/

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
MagicWord Overview
Relevant source files
LICENSE
README.md
README_EN.md
app/build.gradle.kts
app/src/main/java/com/magicword/app/ui/MainScreen.kt
Purpose and Scope
This document provides a high-level introduction to the MagicWord vocabulary learning system, explaining its purpose, architecture, and core capabilities. For detailed information about the three-tier architecture and component interactions, see
System Architecture
. For development environment setup and configuration, see
Getting Started
. Detailed documentation of the Android client is available at
Android Application
, and cloud infrastructure details are covered in
Cloud Infrastructure
.
What is MagicWord?
MagicWord is a serverless vocabulary learning application that combines mobile-first design with cloud-based library sharing. The system consists of three integrated tiers:
Android Client
: Native mobile application built with Jetpack Compose implementing MVVM architecture
Cloudflare Worker
: Edge-hosted API gateway and proxy service deployed at
mag.upxuu.com
GitHub Data Warehouse
: Git-based storage using repositories
lijiaxu2021/MagicWord
(app distribution) and
lijiaxu2021/magicwordfile
(vocabulary libraries)
The application eliminates traditional backend servers by leveraging edge computing (Cloudflare Workers) and version-controlled storage (GitHub), enabling a fully distributed architecture with zero database hosting costs.
Sources
:
README.md
1-43
Core Capabilities
Vocabulary Learning Features
Feature
Description
Implementation
Spaced Repetition
SuperMemo-2 algorithm for optimal review scheduling
SM-2Algorithm.kt
with ease factor calculation
AI-Powered Definitions
Word definitions and mnemonics via Qwen2.5-7B-Instruct
Retrofit client to
api.siliconflow.cn
Bulk Import
Extract vocabulary from long text passages
Chunked parallel AI processing with retry queue
Multiple Quiz Modes
Choice-based and spelling tests
TestScreen
with session persistence
Text-to-Speech
Native pronunciation support
Android TTS integration
Full-Text Search
Fast word lookup across libraries
Room FTS4 implementation in
WordDao
Library Ecosystem Features
Feature
Description
Implementation
Local Libraries
Offline vocabulary collections with CRUD operations
Room entities:
Library
,
Word
Online Library Catalog
Browse and download community-shared libraries
Paginated indexes via GitHub Pages
Tag-Based Discovery
Filter libraries by metadata tags
tags.json
auto-generated by GitHub Actions
Upload Gateway
Share local libraries to the cloud
Cloudflare Worker commits to
magicwordfile
repo
JSON Import/Export
Portable library format
Standardized schema with Base64 encoding
System Features
Feature
Description
Implementation
Self-Updating
In-app APK download and installation
UpdateManager
checks GitHub Releases
Notice System
Server-side announcements
notice.json
with read-state tracking
Key-Kit Verification
API key validation system
Settings screen with credential management
Log Management
Debug and feature usage logs
LogUtil
with persistent storage
Sources
:
README.md
50-74
README_EN.md
19-47
app/src/main/java/com/magicword/app/ui/MainScreen.kt
82-106
System Architecture Overview
Three-Tier Architecture
Diagram
: Component relationships mapping natural language system names to code entities
Sources
:
README.md
24-43
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
Data Flow Pattern
The system implements a reactive unidirectional data flow:
Diagram
: Data flow pattern showing how user interactions propagate through the ViewModel layer
The
LibraryViewModel
exposes 17+ StateFlow properties that UI screens observe via
collectAsState()
. All database mutations trigger automatic Flow emissions, eliminating manual UI update logic.
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-206
Technology Stack
Android Client Technologies
Layer
Technology
Key Components
UI
Jetpack Compose 1.5.4
MainScreen
,
WordsScreen
,
StudyScreen
,
TestScreen
Architecture
MVVM + StateFlow
LibraryViewModel
(importance: 47.90)
Database
Room 2.6.1
AppDatabase
,
WordDao
(with FTS4),
LibraryDao
,
TestSessionDao
Networking
Retrofit 2.9.0 + OkHttp
AI API client, GitHub proxy client
Concurrency
Kotlin Coroutines + Flow
Asynchronous operations, reactive streams
Background Tasks
WorkManager 2.9.0
SyncWorker
for periodic sync
UI Components
Material3 + Reorderable 2.4.3
Drag-and-drop word reordering
Build System
Gradle KTS 8.0
Kotlin DSL configuration, KSP for annotation processing
Cloud Infrastructure Technologies
Component
Technology
Purpose
Edge Compute
Cloudflare Workers
Serverless API gateway and CORS proxy
Static Hosting
GitHub Pages
Raw content delivery for libraries and indexes
CI/CD
GitHub Actions
Automated index generation, APK builds
Storage
Git Repository
Version-controlled library storage
External Services
Service
Provider
Usage
AI Model
SiliconFlow (Qwen2.5-7B-Instruct)
Word definitions, mnemonics, bulk extraction
Update Distribution
GitHub Releases
APK hosting and version management
Sources
:
app/build.gradle.kts
1-108
README.md
78-96
Application Module Breakdown
UI Screen Hierarchy
Diagram
: Navigation structure mapping screen names to actual code files
Navigation Implementation
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
188-284
Screen Responsibilities
Screen
File
Primary Functions
MainScreen
MainScreen.kt
Tab management, update checks, notice dialogs, navigation hub
WordsScreen
WordsScreen.kt
Card/list view toggle, word CRUD, search, bulk import
StudyScreen
StudyScreen.kt
Flashcard review, SM-2 scheduling, library selection
TestScreen
TestScreen.kt
Multiple choice/spelling tests, history tracking
WordListScreen
WordListScreen.kt
Custom word collections, grouping logic
LibraryManagerScreen
LibraryManagerScreen.kt
Local library CRUD, online library browser, upload gateway
SettingsScreen
SettingsScreen.kt
AI configuration, Key-Kit system, log management
SearchScreen
SearchScreen.kt
AI-powered global word search, one-click save
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
234-276
Serverless Architecture Design
Why Serverless?
MagicWord eliminates traditional backend infrastructure through three strategic design choices:
Cloudflare Workers as API Gateway
: Handles CORS, routing, and upload processing at the edge with zero server maintenance
GitHub as Database
: Leverages Git's version control and GitHub Pages for static content delivery
GitHub Actions as Compute
: Automatically generates indexes and metadata on each library upload
Cost and Scalability Benefits
Traditional Stack
MagicWord Serverless
VPS hosting ($5-20/month)
Cloudflare Workers free tier
Database server (PostgreSQL, MySQL)
GitHub repository (free)
CDN for assets
GitHub Pages (free)
Cron jobs for indexing
GitHub Actions (2000 min/month free)
SSL certificates
Automatic (Cloudflare + GitHub)
This architecture supports unlimited users with zero operational costs below GitHub's free tier limits (2GB storage, 2000 action minutes/month).
CORS and Network Restrictions
The Cloudflare Worker solves two critical problems:
CORS Issues
: GitHub Raw Content blocks cross-origin requests from Android apps. The worker adds appropriate headers.
Network Accessibility
: Some regions restrict direct GitHub access. The worker deployed at
mag.upxuu.com
provides an alternate endpoint.
Worker Routing
: The
cf.js
script implements five primary routes documented in
Cloudflare Worker - API Gateway
.
Sources
:
README.md
24-43
README.md
81-96
Key Design Patterns
Repository as Database
The
magicwordfile
repository structure mimics a traditional database:
magicwordfile/ (Git Repository)
├── index_0.json        → Database Index (Page 0 - Latest)
├── index_1.json        → Database Index (Page 1)
├── num.json            → Metadata Table (Total pages, items)
├── tags.json           → Tag Aggregation Table
└── {timestamp}/        → Library Records
    ├── info.json       → Record Metadata
    └── library.json    → Record Data
Automatic Indexing
: On each push to
magicwordfile
, the
update_index.yml
workflow scans all timestamp directories, extracts metadata, and regenerates paginated indexes. This simulates database triggers and materialized views.
Sources
:
README.md
99-124
State Management Pattern
The Android client uses a
single ViewModel pattern
where
LibraryViewModel
serves as the sole state manager:
17+ StateFlow Properties
: All UI state (current library, due words, test sessions, online libraries, etc.)
Derived Flows
: Computed state using
combine()
and
flatMapLatest()
operators
Single Source of Truth
: SharedPreferences and Room updates automatically trigger StateFlow emissions
This eliminates state synchronization bugs and provides automatic UI updates through
collectAsState()
.
ViewModel Implementation
: Documented in detail at
LibraryViewModel - Central State Manager
.
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-206
System Initialization Flow
Diagram
: Application startup sequence showing initialization dependencies
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
Configuration Management
Build Configuration
Application metadata and signing configuration are managed in
app/build.gradle.kts
:
Property
Value
Purpose
applicationId
com.magicword.app
Unique package identifier
versionCode
22
Numeric version for updates
versionName
"0.0.21"
User-facing version string
minSdk
24 (Android 7.0)
Minimum supported OS
targetSdk
34 (Android 14)
Target OS version
compileSdk
34
Build tools version
Signing Configuration
: Release builds require keystore credentials via environment variables (
KEYSTORE_PATH
,
STORE_PASSWORD
,
KEY_ALIAS
,
KEY_PASSWORD
) for CI/CD compatibility.
Sources
:
app/build.gradle.kts
8-49
Runtime Configuration
The
AppConfig
singleton (documented in
SettingsScreen & Configuration
) manages runtime settings:
AI API keys (SiliconFlow)
Model parameters (temperature, max tokens)
Save location preferences
TTS settings
These are persisted in SharedPreferences and exposed through
SettingsScreen
.
Next Steps
For detailed information about specific subsystems, refer to:
System Architecture
: Deep dive into component interactions and data flow
Getting Started
: Development environment setup and build instructions
Android Application
: Complete Android client documentation
Cloud Infrastructure
: Cloudflare Worker and GitHub integration details
Development & Deployment
: CI/CD pipeline and release process
Sources
:
README.md
1-218
app/build.gradle.kts
1-108
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
MagicWord Overview
Purpose and Scope
What is MagicWord?
Core Capabilities
Vocabulary Learning Features
Library Ecosystem Features
System Features
System Architecture Overview
Three-Tier Architecture
Data Flow Pattern
Technology Stack
Android Client Technologies
Cloud Infrastructure Technologies
External Services
Application Module Breakdown
UI Screen Hierarchy
Screen Responsibilities
Serverless Architecture Design
Why Serverless?
Cost and Scalability Benefits
CORS and Network Restrictions
Key Design Patterns
Repository as Database
State Management Pattern
System Initialization Flow
Configuration Management
Build Configuration
Runtime Configuration
Next Steps

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/1-magicword-overview

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
MagicWord Overview
Relevant source files
LICENSE
README.md
README_EN.md
app/build.gradle.kts
app/src/main/java/com/magicword/app/ui/MainScreen.kt
Purpose and Scope
This document provides a high-level introduction to the MagicWord vocabulary learning system, explaining its purpose, architecture, and core capabilities. For detailed information about the three-tier architecture and component interactions, see
System Architecture
. For development environment setup and configuration, see
Getting Started
. Detailed documentation of the Android client is available at
Android Application
, and cloud infrastructure details are covered in
Cloud Infrastructure
.
What is MagicWord?
MagicWord is a serverless vocabulary learning application that combines mobile-first design with cloud-based library sharing. The system consists of three integrated tiers:
Android Client
: Native mobile application built with Jetpack Compose implementing MVVM architecture
Cloudflare Worker
: Edge-hosted API gateway and proxy service deployed at
mag.upxuu.com
GitHub Data Warehouse
: Git-based storage using repositories
lijiaxu2021/MagicWord
(app distribution) and
lijiaxu2021/magicwordfile
(vocabulary libraries)
The application eliminates traditional backend servers by leveraging edge computing (Cloudflare Workers) and version-controlled storage (GitHub), enabling a fully distributed architecture with zero database hosting costs.
Sources
:
README.md
1-43
Core Capabilities
Vocabulary Learning Features
Feature
Description
Implementation
Spaced Repetition
SuperMemo-2 algorithm for optimal review scheduling
SM-2Algorithm.kt
with ease factor calculation
AI-Powered Definitions
Word definitions and mnemonics via Qwen2.5-7B-Instruct
Retrofit client to
api.siliconflow.cn
Bulk Import
Extract vocabulary from long text passages
Chunked parallel AI processing with retry queue
Multiple Quiz Modes
Choice-based and spelling tests
TestScreen
with session persistence
Text-to-Speech
Native pronunciation support
Android TTS integration
Full-Text Search
Fast word lookup across libraries
Room FTS4 implementation in
WordDao
Library Ecosystem Features
Feature
Description
Implementation
Local Libraries
Offline vocabulary collections with CRUD operations
Room entities:
Library
,
Word
Online Library Catalog
Browse and download community-shared libraries
Paginated indexes via GitHub Pages
Tag-Based Discovery
Filter libraries by metadata tags
tags.json
auto-generated by GitHub Actions
Upload Gateway
Share local libraries to the cloud
Cloudflare Worker commits to
magicwordfile
repo
JSON Import/Export
Portable library format
Standardized schema with Base64 encoding
System Features
Feature
Description
Implementation
Self-Updating
In-app APK download and installation
UpdateManager
checks GitHub Releases
Notice System
Server-side announcements
notice.json
with read-state tracking
Key-Kit Verification
API key validation system
Settings screen with credential management
Log Management
Debug and feature usage logs
LogUtil
with persistent storage
Sources
:
README.md
50-74
README_EN.md
19-47
app/src/main/java/com/magicword/app/ui/MainScreen.kt
82-106
System Architecture Overview
Three-Tier Architecture
Diagram
: Component relationships mapping natural language system names to code entities
Sources
:
README.md
24-43
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
Data Flow Pattern
The system implements a reactive unidirectional data flow:
Diagram
: Data flow pattern showing how user interactions propagate through the ViewModel layer
The
LibraryViewModel
exposes 17+ StateFlow properties that UI screens observe via
collectAsState()
. All database mutations trigger automatic Flow emissions, eliminating manual UI update logic.
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-206
Technology Stack
Android Client Technologies
Layer
Technology
Key Components
UI
Jetpack Compose 1.5.4
MainScreen
,
WordsScreen
,
StudyScreen
,
TestScreen
Architecture
MVVM + StateFlow
LibraryViewModel
(importance: 47.90)
Database
Room 2.6.1
AppDatabase
,
WordDao
(with FTS4),
LibraryDao
,
TestSessionDao
Networking
Retrofit 2.9.0 + OkHttp
AI API client, GitHub proxy client
Concurrency
Kotlin Coroutines + Flow
Asynchronous operations, reactive streams
Background Tasks
WorkManager 2.9.0
SyncWorker
for periodic sync
UI Components
Material3 + Reorderable 2.4.3
Drag-and-drop word reordering
Build System
Gradle KTS 8.0
Kotlin DSL configuration, KSP for annotation processing
Cloud Infrastructure Technologies
Component
Technology
Purpose
Edge Compute
Cloudflare Workers
Serverless API gateway and CORS proxy
Static Hosting
GitHub Pages
Raw content delivery for libraries and indexes
CI/CD
GitHub Actions
Automated index generation, APK builds
Storage
Git Repository
Version-controlled library storage
External Services
Service
Provider
Usage
AI Model
SiliconFlow (Qwen2.5-7B-Instruct)
Word definitions, mnemonics, bulk extraction
Update Distribution
GitHub Releases
APK hosting and version management
Sources
:
app/build.gradle.kts
1-108
README.md
78-96
Application Module Breakdown
UI Screen Hierarchy
Diagram
: Navigation structure mapping screen names to actual code files
Navigation Implementation
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
188-284
Screen Responsibilities
Screen
File
Primary Functions
MainScreen
MainScreen.kt
Tab management, update checks, notice dialogs, navigation hub
WordsScreen
WordsScreen.kt
Card/list view toggle, word CRUD, search, bulk import
StudyScreen
StudyScreen.kt
Flashcard review, SM-2 scheduling, library selection
TestScreen
TestScreen.kt
Multiple choice/spelling tests, history tracking
WordListScreen
WordListScreen.kt
Custom word collections, grouping logic
LibraryManagerScreen
LibraryManagerScreen.kt
Local library CRUD, online library browser, upload gateway
SettingsScreen
SettingsScreen.kt
AI configuration, Key-Kit system, log management
SearchScreen
SearchScreen.kt
AI-powered global word search, one-click save
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
234-276
Serverless Architecture Design
Why Serverless?
MagicWord eliminates traditional backend infrastructure through three strategic design choices:
Cloudflare Workers as API Gateway
: Handles CORS, routing, and upload processing at the edge with zero server maintenance
GitHub as Database
: Leverages Git's version control and GitHub Pages for static content delivery
GitHub Actions as Compute
: Automatically generates indexes and metadata on each library upload
Cost and Scalability Benefits
Traditional Stack
MagicWord Serverless
VPS hosting ($5-20/month)
Cloudflare Workers free tier
Database server (PostgreSQL, MySQL)
GitHub repository (free)
CDN for assets
GitHub Pages (free)
Cron jobs for indexing
GitHub Actions (2000 min/month free)
SSL certificates
Automatic (Cloudflare + GitHub)
This architecture supports unlimited users with zero operational costs below GitHub's free tier limits (2GB storage, 2000 action minutes/month).
CORS and Network Restrictions
The Cloudflare Worker solves two critical problems:
CORS Issues
: GitHub Raw Content blocks cross-origin requests from Android apps. The worker adds appropriate headers.
Network Accessibility
: Some regions restrict direct GitHub access. The worker deployed at
mag.upxuu.com
provides an alternate endpoint.
Worker Routing
: The
cf.js
script implements five primary routes documented in
Cloudflare Worker - API Gateway
.
Sources
:
README.md
24-43
README.md
81-96
Key Design Patterns
Repository as Database
The
magicwordfile
repository structure mimics a traditional database:
magicwordfile/ (Git Repository)
├── index_0.json        → Database Index (Page 0 - Latest)
├── index_1.json        → Database Index (Page 1)
├── num.json            → Metadata Table (Total pages, items)
├── tags.json           → Tag Aggregation Table
└── {timestamp}/        → Library Records
    ├── info.json       → Record Metadata
    └── library.json    → Record Data
Automatic Indexing
: On each push to
magicwordfile
, the
update_index.yml
workflow scans all timestamp directories, extracts metadata, and regenerates paginated indexes. This simulates database triggers and materialized views.
Sources
:
README.md
99-124
State Management Pattern
The Android client uses a
single ViewModel pattern
where
LibraryViewModel
serves as the sole state manager:
17+ StateFlow Properties
: All UI state (current library, due words, test sessions, online libraries, etc.)
Derived Flows
: Computed state using
combine()
and
flatMapLatest()
operators
Single Source of Truth
: SharedPreferences and Room updates automatically trigger StateFlow emissions
This eliminates state synchronization bugs and provides automatic UI updates through
collectAsState()
.
ViewModel Implementation
: Documented in detail at
LibraryViewModel - Central State Manager
.
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-206
System Initialization Flow
Diagram
: Application startup sequence showing initialization dependencies
Sources
:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
Configuration Management
Build Configuration
Application metadata and signing configuration are managed in
app/build.gradle.kts
:
Property
Value
Purpose
applicationId
com.magicword.app
Unique package identifier
versionCode
22
Numeric version for updates
versionName
"0.0.21"
User-facing version string
minSdk
24 (Android 7.0)
Minimum supported OS
targetSdk
34 (Android 14)
Target OS version
compileSdk
34
Build tools version
Signing Configuration
: Release builds require keystore credentials via environment variables (
KEYSTORE_PATH
,
STORE_PASSWORD
,
KEY_ALIAS
,
KEY_PASSWORD
) for CI/CD compatibility.
Sources
:
app/build.gradle.kts
8-49
Runtime Configuration
The
AppConfig
singleton (documented in
SettingsScreen & Configuration
) manages runtime settings:
AI API keys (SiliconFlow)
Model parameters (temperature, max tokens)
Save location preferences
TTS settings
These are persisted in SharedPreferences and exposed through
SettingsScreen
.
Next Steps
For detailed information about specific subsystems, refer to:
System Architecture
: Deep dive into component interactions and data flow
Getting Started
: Development environment setup and build instructions
Android Application
: Complete Android client documentation
Cloud Infrastructure
: Cloudflare Worker and GitHub integration details
Development & Deployment
: CI/CD pipeline and release process
Sources
:
README.md
1-218
app/build.gradle.kts
1-108
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
MagicWord Overview
Purpose and Scope
What is MagicWord?
Core Capabilities
Vocabulary Learning Features
Library Ecosystem Features
System Features
System Architecture Overview
Three-Tier Architecture
Data Flow Pattern
Technology Stack
Android Client Technologies
Cloud Infrastructure Technologies
External Services
Application Module Breakdown
UI Screen Hierarchy
Screen Responsibilities
Serverless Architecture Design
Why Serverless?
Cost and Scalability Benefits
CORS and Network Restrictions
Key Design Patterns
Repository as Database
State Management Pattern
System Initialization Flow
Configuration Management
Build Configuration
Runtime Configuration
Next Steps

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/1.1-system-architecture

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
System Architecture
Relevant source files
LICENSE
README.md
README_EN.md
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
cf.js
verify_online_api.py
verify_proxy.py
Purpose and Scope
This document provides a detailed explanation of MagicWord's three-tier system architecture, including the Android client application, Cloudflare Worker proxy layer, and GitHub-based data warehouse. It covers the component interactions, data flow patterns, and network topology that enable the system's vocabulary learning and sharing capabilities.
For information about specific Android UI components and screens, see
User Interface Screens
. For build configuration details, see
Build Configuration
. For cloud infrastructure deployment, see
Cloud Infrastructure
.
Architecture Overview
MagicWord implements a
three-tier serverless architecture
that eliminates the need for traditional backend servers while providing full CRUD capabilities for vocabulary libraries.
System Tiers
Tier 1 (Android Client)
handles all user interactions, local persistence, and application state. The client is a self-contained unit that can function offline for core vocabulary management and review.
Tier 2 (Cloud Infrastructure)
uses a serverless architecture where Cloudflare Workers act as an intelligent API gateway, GitHub serves as both storage (via GitHub Pages) and compute (via GitHub Actions), enabling dynamic library discovery without database servers.
Tier 3 (External Services)
provides AI-powered word definitions and application updates. The AI service is accessed directly to avoid proxy latency for definition generation.
Sources:
README.md
24-42
cf.js
1-239
Diagram 1 from context
Android Client Architecture
The Android application follows
MVVM (Model-View-ViewModel) architecture
with unidirectional data flow powered by Kotlin Coroutines and StateFlow.
Component Hierarchy
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-111
Diagram 2 from context
Core Component Responsibilities
Component
Responsibility
Key Methods/Properties
LibraryViewModel
Single source of truth for all application state. Coordinates between UI and data layers.
17+ StateFlows,
processReview()
,
bulkImport()
,
handleGlobalSearch()
WordDao
Room DAO for word CRUD operations with FTS4 full-text search.
searchWords()
,
getDueWordsForLibraries()
,
getWordsByLibrary()
LibraryDao
Manages library metadata (name, description, lastIndex).
getAllLibraries()
,
insertLibrary()
,
deleteLibrary()
TestSessionDao
Persists test session state for resumability.
saveTestSession()
,
getTestSession()
,
clearTestSession()
RetrofitClient
HTTP client for AI API calls (word definitions, bulk extraction).
Configured for Qwen/SiliconFlow endpoints
OkHttpClient
Direct HTTP client for file operations (library downloads, APK updates).
Used by
LibraryViewModel
and
UpdateManager
SharedPreferences
Lightweight persistence for current library ID, sort options, study selections.
Keys:
current_library_id
,
sort_option
,
study_library_ids
AppConfig
Singleton for global configuration (API keys, model name, user persona).
modelName
,
apiKey
,
userPersona
,
saveLocationId
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-111
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-219
LibraryViewModel: Central State Manager
The
LibraryViewModel
is the heavyweight core (47.90% importance) that manages all application state through reactive StateFlows.
StateFlow Architecture
StateFlow Categories
Persistent State (synced with SharedPreferences):
currentLibraryId: StateFlow<Int>
- Current active library
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-168
studyLibraryIds: StateFlow<Set<Int>>
- Libraries selected for study mode
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
173-181
sortOption: StateFlow<SortOption>
- Current word sorting method
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
255-262
Derived State (computed from database):
allWords: Flow<List<Word>>
- Words in current library with applied sorting
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
dueWords: Flow<List<Word>>
- Words due for review based on SM-2 algorithm
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
allLibraries: Flow<List<Library>>
- All available libraries
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
440
testHistory: Flow<List<TestHistory>>
- All test results
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
514
Transient State (UI-driven):
searchResults: StateFlow<List<Word>>
- Search query results
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
269-270
globalSearchResult: StateFlow<Word?>
- AI search result
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
272-273
testSession: StateFlow<TestSession?>
- Active test session (persisted to Room)
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
489-496
testCandidates: StateFlow<List<Word>?>
- Words for current test
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
481-482
testType: StateFlow<TestType>
- Choice or Spell mode
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
473-474
Loading/Status State:
isImporting: StateFlow<Boolean>
- Bulk import in progress
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
465-466
importLogs: StateFlow<List<String>>
- Real-time import logs
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
462-463
isGlobalSearching: StateFlow<Boolean>
- AI search in progress
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
275-276
isNetworkLoading: StateFlow<Boolean>
- Online library fetch status
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
71-72
isTtsReady: StateFlow<Boolean>
- Text-to-speech initialization status
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
76-77
Online Library State:
onlineLibraries: StateFlow<List<OnlineLibrary>>
- Available cloud libraries
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
68-69
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-276
Diagram 3 from context
Data Flow Patterns
MagicWord implements three distinct data flow patterns based on operation type.
Pattern 1: Local CRUD Flow
Local CRUD operations trigger automatic UI updates through Flow emissions from Room database queries. The ViewModel subscribes to database Flows, which emit new data whenever the underlying tables change.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
529-533
Pattern 2: Remote Fetch Flow
Remote operations update loading state, fetch data, update result state, and clear loading state. This pattern prevents race conditions and provides clear UI feedback.
Sources:
cf.js
60-66
Network architecture from context
Pattern 3: Derived Flow (Reactive Computation)
The
dueWords
Flow is computed by combining
currentLibraryId
and
studyLibraryIds
, then using
flatMapLatest
to query the database. Any change to either source Flow triggers a new database query and emission.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
Cloud Infrastructure: Cloudflare Worker
The
cf.js
script deployed on Cloudflare Workers acts as the system's API gateway, abstracting GitHub's raw content delivery and handling CORS issues.
Request Routing
Sources:
cf.js
39-85
Route Details
Route
Method
Purpose
Target Repository
Function
/MagicWordLatest.apk
GET
APK download
MagicWord/main
fetchRawFile()
cf.js
44-46
/notice.json
GET
System announcements
MagicWord/main
fetchRawFile()
cf.js
49-51
/library/file/{path}
GET
Proxy library files (index_*.json, tags.json, etc.)
magicwordfile/main
fetchRawFile()
cf.js
62-66
/library/upload
POST
Upload new library
magicwordfile/main
handleLibraryUpload()
cf.js
69-71
/api/{path}
GET/POST
Proxy GitHub API
GitHub API
proxyRequest()
cf.js
74-78
Upload Gateway Implementation
The upload route receives JSON payloads with base64-encoded library content and creates a timestamped folder structure:
Sources:
cf.js
126-176
cf.js
181-203
GitHub Data Warehouse
The
magicwordfile
repository serves as a static file database with automated indexing via GitHub Actions.
Repository Structure
magicwordfile/
├── .github/workflows/update_index.yml    # Auto-indexing workflow
├── index_0.json                          # Page 0 (latest 10 libraries)
├── index_1.json                          # Page 1 (next 10)
├── num.json                              # Metadata: totalPages, totalItems
├── tags.json                             # Tag statistics: [{name, count}]
├── 1770900184827/                        # Library folder (timestamp)
│   ├── info.json                         # {id, name, description, tags, timestamp, author}
│   └── library.json                      # [{word, definitionCn, ...}]
└── 1770900184828/
    ├── info.json
    └── library.json
Sources:
README.md
101-114
GitHub Actions Automation
The
update_index.yml
workflow triggers on every push to regenerate indexes:
Scan Folders
: Enumerate all timestamp directories
Parse Metadata
: Read each
info.json
to extract name, description, tags
Sort
: Order by timestamp (descending, newest first)
Paginate
: Split into chunks of 10, generate
index_0.json
,
index_1.json
, etc.
Generate num.json
: Write
{totalPages, totalItems, pageSize, lastUpdated}
Generate tags.json
: Aggregate all tags with counts, sort by popularity
Commit
: Push all generated files back to repository
Sources:
README.md
116-124
cf.js
126-176
Network Protocol Specification
The Android client communicates with the cloud infrastructure using standardized JSON protocols.
Pagination Protocol
Data Transfer Objects
num.json
(Metadata):
index_{page}.json
(Library Catalog):
tags.json
(Tag Statistics):
notice.json
(System Announcements):
Sources:
README.md
127-193
cf.js
39-85
Key Design Patterns
1. Serverless Backend Architecture
The system eliminates traditional database servers by leveraging:
GitHub as Storage
: Repositories serve as the persistent data layer
GitHub Actions as Compute
: Automated workflows handle indexing and aggregation
Cloudflare Workers as Gateway
: Edge computing handles request routing and CORS
This design provides:
Zero infrastructure cost
(free tiers of GitHub + Cloudflare)
Global CDN distribution
(GitHub Raw + Cloudflare edge network)
Automatic scaling
(serverless by nature)
Git-based versioning
(all data changes are auditable commits)
Sources:
README.md
24-42
cf.js
1-239
2. Reactive State Management
The Android client implements a
unidirectional data flow
pattern:
User Action → ViewModel Method → Data Layer Update → Flow Emission → StateFlow Update → UI Recomposition
This ensures:
Single source of truth
: All state managed by
LibraryViewModel
Predictable updates
: State changes only flow in one direction
Automatic UI sync
: Compose's
collectAsState()
handles recomposition
Configuration survival
:
rememberSaveable
and SharedPreferences persist state across process death
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-276
Diagram 3 from context
3. Hybrid Data Persistence
Three-tier persistence hierarchy optimizes for different data lifecycles:
Tier
Technology
Use Case
Lifecycle
Temporary
In-memory State +
rememberSaveable
UI transient state (dialog visibility, scroll position)
Configuration change survival
Lightweight
SharedPreferences
User preferences (current library, sort option)
Application lifecycle
Durable
Room Database
Vocabulary data, test results, review schedules
Permanent storage
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-219
Diagram 3 from context
4. Network Abstraction Layer
The Cloudflare Worker abstracts GitHub's limitations:
CORS Bypass
: Adds
Access-Control-Allow-Origin: *
headers
cf.js
112
Cache Control
: Appends timestamps to prevent stale content
cf.js
98
API Gateway
: Unified endpoint for all cloud operations
Region Accessibility
: Bypasses GitHub access restrictions in certain networks
Sources:
cf.js
95-121
README.md
80-94
Performance Characteristics
Android Client
Database Queries
: Room queries execute on background threads via Coroutines
FTS4 Search
: Full-text search indexed for sub-millisecond word lookup
Pagination
: Online libraries loaded page-by-page (10 items per page) to reduce memory footprint
Concurrent AI Calls
: Bulk import uses parallel coroutines (max 3 concurrent) with retry queue
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
772-790
Cloud Infrastructure
Edge Computing
: Cloudflare Workers execute at CDN edge nodes (~50ms global latency)
Static File Delivery
: GitHub Raw content served via global CDN
GitHub Actions Latency
: Index regeneration triggers within seconds of upload, completes in ~10-30 seconds
Rate Limits
: Cloudflare Workers (100k requests/day free tier), GitHub API (5000 requests/hour authenticated)
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-815
cf.js
39-85
Security Considerations
Authentication
GitHub Token
: Required for write operations (library uploads)
cf.js
24
Configured as Cloudflare Worker environment variable
Never exposed to client
API Keys
: AI service keys stored in
AppConfig
singleton
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
49
User-provided, stored in SharedPreferences
Transmitted directly to AI service (not through proxy)
Data Validation
Upload Sanitization
: Worker validates required fields (name, contentBase64) before GitHub commit
cf.js
131-133
JSON Parsing
: Client-side try-catch wrappers around Gson parsing to handle malformed data
Base64 Encoding
: All file content transmitted as base64 to prevent encoding issues
cf.js
148-150
Sources:
cf.js
126-176
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
644-696
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
System Architecture
Purpose and Scope
Architecture Overview
System Tiers
Android Client Architecture
Component Hierarchy
Core Component Responsibilities
LibraryViewModel: Central State Manager
StateFlow Architecture
StateFlow Categories
Data Flow Patterns
Pattern 1: Local CRUD Flow
Pattern 2: Remote Fetch Flow
Pattern 3: Derived Flow (Reactive Computation)
Cloud Infrastructure: Cloudflare Worker
Request Routing
Route Details
Upload Gateway Implementation
GitHub Data Warehouse
Repository Structure
GitHub Actions Automation
Network Protocol Specification
Pagination Protocol
Data Transfer Objects
Key Design Patterns
1. Serverless Backend Architecture
2. Reactive State Management
3. Hybrid Data Persistence
4. Network Abstraction Layer
Performance Characteristics
Android Client
Cloud Infrastructure
Security Considerations
Authentication
Data Validation

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/1.2-getting-started

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Getting Started
Relevant source files
.github/workflows/android.yml
app/build.gradle.kts
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
app/src/main/java/com/magicword/app/utils/AppConfig.kt
app/src/main/res/values/strings.xml
settings.gradle.kts
This guide covers the initial setup required to build and develop the MagicWord Android application, including environment prerequisites, build configuration, API key management, and the configuration system architecture. For information about the overall system architecture and component interactions, see
System Architecture
. For details about specific Android components and UI screens, see
Android Application
.
Purpose and Scope
This document provides step-by-step instructions for:
Setting up the development environment
Understanding the build configuration and signing requirements
Configuring API keys and application settings
Building the Android application locally and via CI/CD
Understanding the
AppConfig
and
SharedPreferences
persistence system
Prerequisites
The following tools and versions are required to build MagicWord:
Requirement
Version
Notes
JDK
17
Required by the Gradle build system
Android Studio
2023.1.1+
Arctic Fox or newer recommended
Android SDK
API 34 (compile)
Minimum API 24 (Android 7.0)
Kotlin
1.9.10+
Bundled with Android Studio
Gradle
8.2+
Managed via wrapper
Sources:
app/build.gradle.kts
10-16
.github/workflows/android.yml
19-24
Initial Setup
Cloning the Repository
Opening in Android Studio
Launch Android Studio
Select
File → Open
Navigate to the cloned
MagicWord
directory
Click
OK
to import the Gradle project
Wait for Gradle sync to complete
The project uses Kotlin DSL for Gradle configuration, with the main build file located at
app/build.gradle.kts
1-108
The Gradle wrapper (
./gradlew
) is version-managed and will auto-download dependencies on first build.
Sources:
settings.gradle.kts
1-18
app/build.gradle.kts
1-6
Configuration System Architecture
MagicWord uses a three-tier configuration architecture to manage application settings, API credentials, and user preferences.
Configuration Flow Diagram
Sources:
app/src/main/java/com/magicword/app/utils/AppConfig.kt
1-61
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
40-93
Configuration Components
AppConfig Singleton
The
AppConfig
object
app/src/main/java/com/magicword/app/utils/AppConfig.kt
6-61
manages global application settings:
Property
Type
Default
Purpose
apiKey
String
""
AI service API key (required for word definitions)
modelName
String
"Qwen/Qwen2.5-7B-Instruct"
AI model identifier
serverUrl
String
""
AI service base URL
userPersona
String
""
User identity for personalized AI responses
saveLocationId
Int
-1
Target library ID for new words (-1 = current library)
Key Methods:
init(context)
app/src/main/java/com/magicword/app/utils/AppConfig.kt
28-35
- Load configuration from
SharedPreferences
on app launch
saveConfig(...)
app/src/main/java/com/magicword/app/utils/AppConfig.kt
41-55
- Persist configuration changes
isConfigured()
app/src/main/java/com/magicword/app/utils/AppConfig.kt
57-59
- Validate if API key is set
SharedPreferences Files
Two separate preference files are used:
app_config
app/src/main/java/com/magicword/app/utils/AppConfig.kt
7-12
- AI configuration and persistence settings
app_settings
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
42
- UI state and system preferences (logging, auto-update)
Sources:
app/src/main/java/com/magicword/app/utils/AppConfig.kt
6-61
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
40-93
Build Configuration
Gradle Build File Structure
The primary build configuration is defined in
app/build.gradle.kts
1-108
Key configurations include:
Application Metadata
Location:
app/build.gradle.kts
9-17
Core Dependencies
Library
Version
Purpose
Jetpack Compose
BOM 2023.08.00
UI framework
Room
2.6.1
Local database (SQLite with KSP)
Retrofit
2.9.0
Network client for AI API
WorkManager
2.9.0
Background synchronization
Reorderable
2.4.3
Drag-and-drop list reordering
Location:
app/build.gradle.kts
71-107
Sources:
app/build.gradle.kts
1-108
Signing Configuration
Local Development vs. CI/CD
MagicWord requires APK signing for release builds. The signing configuration uses environment variables for CI/CD and falls back to local files for development.
Signing Configuration Diagram
Sources:
app/build.gradle.kts
25-35
.github/workflows/android.yml
29-41
Signing Configuration Code
The signing configuration is defined in
app/build.gradle.kts
25-35
:
Setting Up Local Keystore
For local development, create a keystore file:
Important:
Never commit the keystore file to version control. It should be listed in
.gitignore
.
CI/CD Signing (GitHub Actions)
The CI/CD pipeline
.github/workflows/android.yml
29-41
decodes the keystore from a base64-encoded secret:
Decode Keystore
.github/workflows/android.yml
29-33
- Converts
KEYSTORE_BASE64
secret to binary file
Set Environment Variables
.github/workflows/android.yml
36-40
- Provides signing credentials
Build Signed APK
.github/workflows/android.yml
41
- Executes
./gradlew assembleRelease
Required GitHub Secrets:
KEYSTORE_BASE64
- Base64-encoded keystore file
KEY_ALIAS
- Keystore key alias
KEY_PASSWORD
- Key password
STORE_PASSWORD
- Keystore password
Sources:
app/build.gradle.kts
25-49
.github/workflows/android.yml
29-41
Required API Keys and Secrets
AI Service Configuration
MagicWord requires AI API credentials for word definition and bulk import features. These are managed through the
Key-Kit System
or manual configuration.
Key-Kit System (Recommended)
The Key-Kit system
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
106-147
provides centralized credential management:
User enters Kit key in SettingsScreen
App calls
/verify-kit
endpoint
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
123-124
Server validates key and returns configuration:
apiKey
- AI service API key
model
- Model name (e.g., "Qwen/Qwen2.5-7B-Instruct")
baseUrl
- AI service base URL
Configuration is persisted to
SharedPreferences
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
125-129
Manual Configuration
Alternatively, configure directly in SettingsScreen
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
46-50
:
These values are editable via
OutlinedTextField
components
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
153-168
Configuration Persistence
All configuration changes are saved when exiting SettingsScreen via
DisposableEffect
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
93
:
The
saveAllConfig()
function
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
87-91
persists to both
AppConfig
singleton and
SharedPreferences
.
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
46-93
app/src/main/java/com/magicword/app/utils/AppConfig.kt
41-55
Building the Application
Local Build Commands
Debug Build (Unsigned)
Output:
app/build/outputs/apk/debug/app-debug.apk
Release Build (Signed)
Output:
app/build/outputs/apk/release/app-release.apk
Note:
Release builds require keystore configuration (see
Signing Configuration
).
Build Process Diagram
Sources:
app/build.gradle.kts
37-49
app/build.gradle.kts
50-68
Gradle Tasks
Common Gradle tasks for development:
Task
Command
Purpose
Clean
./gradlew clean
Remove build artifacts
Compile
./gradlew compileDebugKotlin
Compile without packaging
Test
./gradlew test
Run unit tests
Lint
./gradlew lint
Static analysis
Dependencies
./gradlew dependencies
View dependency tree
Sources:
app/build.gradle.kts
1-108
CI/CD Pipeline Overview
GitHub Actions Workflow
The automated build pipeline is defined in
.github/workflows/android.yml
1-90
It triggers on pushes to
main
or
feature/native-android
branches.
CI/CD Workflow Diagram
Sources:
.github/workflows/android.yml
1-90
Build Artifacts
The pipeline produces three APK artifacts:
Actions Artifact
.github/workflows/android.yml
49-53
-
MagicWord-vX.X.X
uploaded to GitHub Actions
Release Asset
.github/workflows/android.yml
60-72
-
MagicWord-vX.X.X.apk
attached to GitHub Release
Latest APK
.github/workflows/android.yml
74-89
-
MagicWordLatest.apk
committed to repository root (used by update system)
Version Extraction
The pipeline extracts
versionName
using
grep
and
awk
.github/workflows/android.yml
43-47
:
This version is used for release tagging and APK naming.
Sources:
.github/workflows/android.yml
43-72
app/build.gradle.kts
16-17
Next Steps
After completing the setup, proceed to:
Android Application
- Overview of the MVVM architecture and UI components
Core Components
- Deep dive into
LibraryViewModel
, Room database, and data persistence
Build Configuration
- Detailed explanation of Gradle configuration and plugin architecture
For information about the cloud infrastructure that supports the application (Cloudflare Worker, GitHub data warehouse), see
Cloud Infrastructure
.
Sources:
app/build.gradle.kts
1-108
.github/workflows/android.yml
1-90
app/src/main/java/com/magicword/app/utils/AppConfig.kt
1-61
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
1-337
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Getting Started
Purpose and Scope
Prerequisites
Initial Setup
Cloning the Repository
Opening in Android Studio
Configuration System Architecture
Configuration Flow Diagram
Configuration Components
AppConfig Singleton
SharedPreferences Files
Build Configuration
Gradle Build File Structure
Application Metadata
Core Dependencies
Signing Configuration
Local Development vs. CI/CD
Signing Configuration Diagram
Signing Configuration Code
Setting Up Local Keystore
CI/CD Signing (GitHub Actions)
Required API Keys and Secrets
AI Service Configuration
Key-Kit System (Recommended)
Manual Configuration
Configuration Persistence
Building the Application
Local Build Commands
Debug Build (Unsigned)
Release Build (Signed)
Build Process Diagram
Gradle Tasks
CI/CD Pipeline Overview
GitHub Actions Workflow
CI/CD Workflow Diagram
Build Artifacts
Version Extraction
Next Steps

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2-android-application

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Android Application
Relevant source files
MagicWordLatest.apk
app/build.gradle.kts
app/src/main/java/com/magicword/app/ui/MainScreen.kt
Purpose and Scope
This document provides an overview of the MagicWord Android client application, covering its architectural patterns, technology stack, component structure, and navigation system. The Android app is a self-contained vocabulary learning application that implements MVVM architecture using Jetpack Compose for UI, Room for local persistence, and Kotlin Coroutines for asynchronous operations.
Related Pages:
For detailed documentation of core components (ViewModel, DAOs, build configuration), see
Core Components
For individual screen implementations and UI patterns, see
User Interface Screens
For cross-cutting features like AI integration and spaced repetition, see
Feature Systems
For cloud infrastructure that the app communicates with, see
Cloud Infrastructure
Architecture Overview
The Android application follows a
Model-View-ViewModel (MVVM)
architecture with clear separation of concerns across three layers:
Architecture Characteristics:
Unidirectional Data Flow
: UI screens emit events to ViewModel, ViewModel updates state, state changes flow back to UI
Single Source of Truth
:
LibraryViewModel
centralizes all application state and business logic
Reactive State
: All UI state is exposed as Kotlin
StateFlow
properties that UI layers collect and observe
Dependency Injection
: Manual DI using factory patterns (
LibraryViewModelFactory
)
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
Technology Stack
The application is built on modern Android development tools and libraries. The following table summarizes the core dependencies and their purposes:
Category
Library
Version
Purpose
UI Framework
Jetpack Compose
BOM 2023.08.00
Declarative UI toolkit
Material 3
Included in BOM
Material Design 3 components
Material Icons Extended
Included in BOM
Extended icon set
Navigation Compose
2.7.5
Screen navigation
Database
Room
2.6.1
SQLite ORM with coroutines support
Networking
Retrofit
2.9.0
HTTP client for AI API
OkHttp
(transitive)
Low-level HTTP for file operations
Gson Converter
2.9.0
JSON serialization/deserialization
Background Work
WorkManager
2.9.0
Scheduled background tasks
UI Utilities
Reorderable
2.4.3
Drag-and-drop list reordering
Language
Kotlin
1.9.x
Primary language
Kotlin Coroutines
(via KTX)
Asynchronous programming
Build Tools
Android Gradle Plugin
8.x
Build system
KSP
Latest
Annotation processing for Room
Build Configuration
The application is configured with the following specifications:
Key Build Configurations:
Namespace
:
com.magicword.app
app/build.gradle.kts
9
Application ID
:
com.magicword.app
app/build.gradle.kts
13
Minimum SDK
: API 24 (Android 7.0 Nougat)
app/build.gradle.kts
14
Target SDK
: API 34 (Android 14)
app/build.gradle.kts
15
Java Compatibility
: Java 8
app/build.gradle.kts
50-52
Kotlin JVM Target
: 1.8
app/build.gradle.kts
54-56
Compose Compiler
: 1.5.4
app/build.gradle.kts
62
Signing Configuration
: The release build uses a signing configuration that reads credentials from environment variables (for CI/CD) or falls back to local defaults. The keystore path, passwords, and alias are parameterized to support automated builds.
app/build.gradle.kts
25-35
Sources:
app/build.gradle.kts
1-108
Application Structure
Navigation System
The app uses a
tab-based navigation
system implemented with
HorizontalPager
and
NavigationBar
, along with an
overlay system
for secondary screens.
Navigation Components:
Component
Code Entity
Purpose
Main Container
MainScreen
composable
Root navigation coordinator
Tab State
pagerState
(PagerState)
Tracks current tab index (0-3)
Overlay State
currentOverlay
(String?)
Tracks active overlay screen
Tab Animations
HorizontalPager
with
userScrollEnabled=true
Swipe gestures between tabs
Navigation Bar
NavigationBar
with 4
NavigationBarItem
s
Bottom tab selector
Screen Definitions
app/src/main/java/com/magicword/app/ui/MainScreen.kt
279-284
:
Initialization and Lifecycle
The
MainScreen
composable performs several initialization tasks on launch:
Initialization Sequence
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
:
Update Check
: Calls
UpdateManager.checkUpdate()
to compare current version with latest GitHub release
Notice Check
: Calls
NoticeManager.checkNotice()
to fetch and display unread system announcements
ViewModel Setup
: Initializes
LibraryViewModel
with
WordDao
and
SharedPreferences
dependencies
State Collection
: Subscribes to
allLibraries
,
currentLibraryId
, and other StateFlows
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
State Management Pattern
The application implements a
centralized reactive state management
pattern where all UI state flows through the
LibraryViewModel
.
State Flow Architecture
State Flow Types
The ViewModel exposes three types of state flows:
Type
Example
Source
Update Mechanism
Database-backed
allWords
,
allLibraries
wordDao.getAllWords().asFlow()
Room triggers emissions on data changes
Preference-backed
currentLibraryId
,
studyLibraryIds
SharedPreferences
listener
Manual emission after pref write
Derived/Computed
dueWords
,
filteredWords
combine()
or
flatMapLatest()
Automatically recomputed when dependencies change
Example: Derived Flow Pattern
The
dueWords
StateFlow is computed by combining
currentLibraryId
with a database query:
currentLibraryId (StateFlow<Long>) 
    → flatMapLatest → wordDao.getDueWords(libraryId).asFlow()
    → dueWords (StateFlow<List<Word>>)
When the user switches libraries,
currentLibraryId
updates, which triggers a new database query, which emits to
dueWords
, which recomposes the UI.
ViewModel Factory Pattern
The app uses manual dependency injection with a factory pattern:
Factory Usage
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-183
:
The factory pattern ensures that:
ViewModel has required dependencies (DAO, SharedPreferences)
ViewModel lifecycle is tied to the composable scope
Configuration changes preserve ViewModel instance
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-186
Data Persistence Architecture
The application uses a
dual-persistence strategy
combining Room database for structured data and SharedPreferences for lightweight settings.
Persistence Layer Mapping
Database Structure
Entity Overview:
Entity
Purpose
Key Features
Word
Stores vocabulary entries
Full-text search (FTS4), SM-2 review fields
Library
Organizes words into collections
Supports import/export as JSON
TestSession
Active test state
Persists incomplete tests
TestHistory
Historical test results
Tracks scores, duration, timestamps
DAO Access Pattern:
DAO
Primary Operations
Return Type
WordDao
CRUD + search queries
Flow<List<Word>>
, suspend functions
LibraryDao
Library management
Flow<List<Library>>
TestSessionDao
Test persistence
Flow<TestSession?>
TestHistoryDao
History queries
Flow<List<TestHistory>>
All DAO query methods return Kotlin
Flow
types that automatically emit new values when the database changes, enabling reactive UI updates.
Sources:
app/build.gradle.kts
84-88
(Room dependencies)
Network Architecture
The application integrates with two distinct network services using different HTTP clients:
Network Layer Separation
Retrofit (AI Service):
Base URL
:
https://api.siliconflow.cn/v1/
(configurable in settings)
Content Type
: JSON requests/responses
Use Cases
:
Single word definition lookup
Bulk text vocabulary extraction
AI-generated mnemonic sentences
Converter
: Gson for automatic JSON serialization
OkHttp (File Operations):
Base URL
:
https://mag.upxuu.com/
(Cloudflare Worker)
Content Type
: Mixed (JSON, binary APK files)
Use Cases
:
Downloading library JSON files
Uploading new libraries to GitHub
Downloading APK updates
Fetching paginated library indexes
Features
: Progress tracking, large file handling
This separation ensures:
AI calls can be retried independently of file operations
Different timeout configurations per service type
Progress tracking for large downloads without affecting API calls
Easy service URL reconfiguration (AI provider can be changed without affecting library system)
Sources:
app/build.gradle.kts
90-93
(Retrofit dependencies)
Coroutine and Threading Model
The application uses Kotlin Coroutines extensively for asynchronous operations:
Coroutine Scopes
Scope
Location
Purpose
Lifecycle
viewModelScope
Inside
LibraryViewModel
Long-running operations (DB writes, network calls)
Tied to ViewModel lifecycle
rememberCoroutineScope()
Composable functions
UI-triggered operations (navigation, one-time actions)
Tied to composition lifecycle
LaunchedEffect
Composable functions
Side effects on composition (init, observers)
Re-triggers on key changes
Threading Strategy
Key Patterns:
Database Operations
: Room automatically runs queries on background threads and emits results to Flows
Network Operations
: Retrofit/OkHttp use
Dispatchers.IO
by default
State Updates
: ViewModel emits state changes on
Dispatchers.Main
to ensure UI thread safety
Heavy Computation
: SM-2 calculations and text parsing use
Dispatchers.Default
Sources:
app/build.gradle.kts
74
(lifecycle-runtime-ktx includes coroutines)
Build System and Compilation
Gradle Plugin Configuration
Plugin Roles
app/build.gradle.kts
1-6
:
Plugin
Version
Purpose
com.android.application
8.x
Android app module configuration
org.jetbrains.kotlin.android
1.9.x
Kotlin compilation for Android
com.google.devtools.ksp
Latest
Kotlin Symbol Processing (replaces kapt)
kotlin-parcelize
Built-in
Automatic Parcelable implementation
Signing and Release Configuration
The release build uses a
parameterized signing configuration
that supports both CI/CD and local builds:
Environment Variable Priority
app/build.gradle.kts
25-34
:
KEYSTORE_PATH → release.jks (default)
STORE_PASSWORD → "password" (default)
KEY_ALIAS → "alias" (default)
KEY_PASSWORD → "password" (default)
In CI/CD pipelines (GitHub Actions):
Keystore file is base64-encoded and stored as a GitHub Secret
During build, the secret is decoded to
release.jks
Environment variables are set from repository secrets
Gradle reads these variables to configure signing
Build Types:
Release
: Signed, not minified (ProGuard disabled for transparency)
Debug
: Unsigned, debuggable
Sources:
app/build.gradle.kts
1-108
Summary
The MagicWord Android application is a modern, reactive mobile app built with:
Architecture
: Clean MVVM with centralized state management
UI
: Jetpack Compose with Material 3 design
Data
: Room database + SharedPreferences dual-persistence
Networking
: Retrofit for AI, OkHttp for file operations
Concurrency
: Kotlin Coroutines with Flow-based reactive streams
Build
: Gradle with automated CI/CD signing
The architecture prioritizes:
Reactivity
: All state flows unidirectionally from ViewModel to UI
Scalability
: Single ViewModel can serve multiple screens
Testability
: Clear separation between presentation, business logic, and data layers
Maintainability
: Declarative UI with Compose reduces boilerplate
For detailed implementation of specific components, refer to the subsection pages:
Core Components
for ViewModel and data layer details
User Interface Screens
for individual screen implementations
Feature Systems
for cross-cutting features like AI integration and spaced repetition
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Android Application
Purpose and Scope
Architecture Overview
Technology Stack
Build Configuration
Application Structure
Navigation System
Initialization and Lifecycle
State Management Pattern
State Flow Architecture
State Flow Types
ViewModel Factory Pattern
Data Persistence Architecture
Persistence Layer Mapping
Database Structure
Network Architecture
Network Layer Separation
Coroutine and Threading Model
Coroutine Scopes
Threading Strategy
Build System and Compilation
Gradle Plugin Configuration
Signing and Release Configuration
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.1-core-components

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Core Components
Relevant source files
app/build.gradle.kts
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
Purpose and Scope
This document describes the foundational components that power the MagicWord Android application. These components form the architectural backbone that supports all feature implementations, including vocabulary management, spaced repetition, AI integration, and testing functionality.
The three core components covered are:
LibraryViewModel
- The central state manager coordinating all data operations and UI state
Data Persistence Layer
- Room database and SharedPreferences for durable and lightweight storage
Build Configuration
- Gradle setup, dependencies, and signing configuration
For detailed implementation of the ViewModel, see
LibraryViewModel - Central State Manager
. For database schema and DAO operations, see
Data Layer & Persistence
. For build system details, see
Build Configuration
.
Component Architecture Overview
The core components follow a clean separation of concerns, with the ViewModel acting as the central coordinator between UI and data layers.
Core Component Dependency Graph
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1196
Component Responsibility Matrix
Component
Primary Responsibility
Key Operations
Persistence
LibraryViewModel
State management, business logic coordination
17+ StateFlow properties, data orchestration
None (in-memory)
WordDao
/ Room
Data access and persistence
CRUD operations, FTS4 search, complex queries
SQLite database
SharedPreferences
Lightweight configuration storage
Current library ID, sort options, study selections
XML file
AppConfig
Global application settings
AI model config, Key-Kit verification, user persona
Singleton + SharedPreferences
RetrofitClient
AI API communication
Word definition fetching, bulk import processing
None
OkHttpClient
Direct HTTP operations
Online library browsing, file downloads, uploads
None
TextToSpeech
Audio pronunciation
Word/phrase pronunciation playback
None
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1196
app/build.gradle.kts
1-108
LibraryViewModel: Central State Manager
The
LibraryViewModel
class serves as the single source of truth for application state. With an importance score of 47.90, it is the most critical component in the codebase.
ViewModel State Properties
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-991
Key StateFlow Properties
Property
Type
Purpose
Persistence
currentLibraryId
StateFlow<Int>
Active library for word viewing
SharedPreferences:
current_library_id
studyLibraryIds
StateFlow<Set<Int>>
Selected libraries for study/review
SharedPreferences:
study_library_ids
allWords
Flow<List<Word>>
Words in current library (sorted)
Derived from Room + sortOption
dueWords
Flow<List<Word>>
Words ready for review (SM-2 filtered)
Derived from Room + studyLibraryIds
sortOption
StateFlow<SortOption>
Current word list sorting mode
SharedPreferences:
sort_option
testSession
StateFlow<TestSession?>
Active test state (progress/answers)
Room:
test_session
table
importLogs
StateFlow<List<String>>
Real-time import progress messages
In-memory only
isImporting
StateFlow<Boolean>
Bulk import loading indicator
In-memory only
onlineLibraries
StateFlow<List<OnlineLibrary>>
Browse/search results from GitHub
In-memory only
globalSearchResult
StateFlow<Word?>
AI lookup result for SearchScreen
In-memory only
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-276
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
463-510
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
68-72
Derived State with Flow Operators
The ViewModel uses Kotlin Flow operators to create reactive computed state:
Implementation example:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
403-418
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
ViewModel Initialization and Lifecycle
The ViewModel performs initialization tasks in its
init
block:
Validate Study Library Selection
- Removes invalid library IDs from persisted selection
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
184-199
Restore Test Session
- Loads incomplete test from database
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
493-497
Initialize TTS Engine
- Called from MainActivity via
initTts(context)
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
79-98
Lifecycle cleanup in
onCleared()
:
Stops and shuts down TextToSpeech engine
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
106-110
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
79-110
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
184-199
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
493-497
Data Persistence Strategy
The application implements a two-tier persistence strategy optimizing for different data access patterns.
Persistence Architecture
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-168
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
535-542
When to Use Each Tier
Room Database
(Durable, Complex Queries):
Vocabulary words with review metadata (SM-2 algorithm fields)
Library definitions and metadata
Test sessions (for crash recovery)
Test history (for analytics)
Word lists (custom groupings)
SharedPreferences
(Fast Access, Simple Values):
Current library ID (frequently read on every screen)
Study library selection (Set
persistence)
Sort option (enum value)
Last viewed word index per library (optimistic updates)
Current word list ID
Rationale:
SharedPreferences provides synchronous, zero-latency reads for frequently accessed configuration values. Room is used for relational data requiring complex queries (FTS4 search, JOIN operations, sorting/filtering).
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-219
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
255-267
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
535-553
Optimistic Update Pattern
For performance-critical operations like card swiping in WordsScreen, the ViewModel uses an optimistic update pattern:
This ensures zero-latency UI updates while maintaining database consistency.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
535-542
Build Configuration and Dependencies
The Gradle build configuration defines the application's compilation settings, dependency management, and signing configuration.
Build Configuration Structure
Sources:
app/build.gradle.kts
1-108
Critical Dependencies
Dependency
Version
Purpose
KSP/Runtime
androidx.room:room-runtime
2.6.1
Database access layer
Runtime
androidx.room:room-compiler
2.6.1
Generates DAO implementations
KSP (compile-time)
com.squareup.retrofit2:retrofit
2.9.0
AI API HTTP client
Runtime
com.squareup.retrofit2:converter-gson
2.9.0
JSON serialization for Retrofit
Runtime
androidx.compose:compose-bom
2023.08.00
Jetpack Compose UI framework
Runtime
sh.calvin.reorderable
2.4.3
Drag-and-drop reordering
Runtime
androidx.work:work-runtime-ktx
2.9.0
Background task scheduling
Runtime
Sources:
app/build.gradle.kts
71-99
Signing Configuration
The build system supports both CI/CD (GitHub Actions) and local development through environment variable fallbacks:
CI/CD Flow:
GitHub Actions workflow decodes base64-encoded keystore from secrets
Sets environment variables:
KEYSTORE_PATH
,
STORE_PASSWORD
,
KEY_ALIAS
,
KEY_PASSWORD
Gradle reads environment variables during release build
Generates signed APK
Sources:
app/build.gradle.kts
25-35
Compiler Options
Setting
Value
Rationale
compileSdk
34
Latest stable Android API
minSdk
24
Android 7.0 (covers 94%+ devices)
targetSdk
34
Required for Play Store submissions
kotlinCompilerExtensionVersion
1.5.4
Compatible with Compose BOM 2023.08.00
jvmTarget
1.8
Kotlin/JVM compatibility
Sources:
app/build.gradle.kts
8-63
Integration Patterns
ViewModel Factory Pattern
The
LibraryViewModel
requires constructor dependencies (
WordDao
,
SharedPreferences
), necessitating a custom factory:
Usage in MainActivity:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1188-1196
Coroutine Scope Management
All asynchronous operations use
viewModelScope
for automatic lifecycle management:
Benefits:
Coroutines automatically cancelled when ViewModel is cleared
Exception handling through
CoroutineExceptionHandler
Structured concurrency prevents memory leaks
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
442-446
Network Layer Separation
The ViewModel uses two HTTP clients for different purposes:
Rationale:
RetrofitClient
: Type-safe API interface, automatic JSON deserialization for AI responses
OkHttpClient
: Direct HTTP access for file downloads, multipart uploads, raw response handling
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
17-18
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
65-66
State Flow Observation in Compose
UI screens observe ViewModel state using the
collectAsState()
extension:
This creates a subscription that:
Automatically updates UI when StateFlow emits new values
Survives configuration changes (rotation, theme change)
Cancels collection when Composable leaves composition
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-276
Summary
The core components form a robust foundation with clear separation of concerns:
LibraryViewModel
centralizes state management with 17+ reactive StateFlow properties
Two-tier persistence
optimizes for different access patterns (Room for complex data, SharedPreferences for configuration)
Build configuration
supports both CI/CD and local development with environment variable fallbacks
Integration patterns
leverage Kotlin Coroutines, Flow operators, and Compose for reactive, lifecycle-aware programming
This architecture enables the application to handle complex features (SM-2 algorithm, AI integration, online library synchronization) while maintaining clean, testable code.
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Core Components
Purpose and Scope
Component Architecture Overview
Core Component Dependency Graph
Component Responsibility Matrix
LibraryViewModel: Central State Manager
ViewModel State Properties
Key StateFlow Properties
Derived State with Flow Operators
ViewModel Initialization and Lifecycle
Data Persistence Strategy
Persistence Architecture
When to Use Each Tier
Optimistic Update Pattern
Build Configuration and Dependencies
Build Configuration Structure
Critical Dependencies
Signing Configuration
Compiler Options
Integration Patterns
ViewModel Factory Pattern
Coroutine Scope Management
Network Layer Separation
State Flow Observation in Compose
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.1.1-libraryviewmodel-central-state-manager

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
LibraryViewModel - Central State Manager
Relevant source files
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
Purpose and Scope
The
LibraryViewModel
is the heavyweight core of the MagicWord Android application, serving as the single source of truth for all application state and coordinating operations between the UI layer and data layer. This document covers:
Architecture and responsibilities of the ViewModel
State management through 17+ StateFlows
Core operations grouped by feature domain
Data flow patterns and reactive transformations
Integration points with Room database, network services, and AI APIs
For information about the Room database structure and DAO implementations, see
Data Layer & Persistence
. For UI screen implementations that consume this ViewModel, see
User Interface Screens
. For AI integration details, see
AI Integration
. For SM-2 algorithm specifics, see
Spaced Repetition System (SM-2)
.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1197
Architecture Overview
The
LibraryViewModel
extends Android's
ViewModel
class and is instantiated via
LibraryViewModelFactory
, which injects dependencies:
WordDao
for database access and
SharedPreferences
for lightweight persistence.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-66
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1188-1196
State Management System
The ViewModel exposes
17+ StateFlows
that UI screens observe via Jetpack Compose's
collectAsState()
. This reactive pattern ensures automatic UI updates when underlying data changes.
Primary StateFlows
StateFlow
Type
Source
Purpose
currentLibraryId
StateFlow<Int>
SharedPreferences
Active library for word management
studyLibraryIds
StateFlow<Set<Int>>
SharedPreferences
Libraries selected for spaced repetition
allWords
Flow<List<Word>>
Derived (DAO + sort)
Words in current library, sorted
dueWords
Flow<List<Word>>
Derived (DAO + study IDs)
Words due for review across selected libraries
sortOption
StateFlow<SortOption>
SharedPreferences
Current sort mode (CREATED_AT_DESC, ALPHA_ASC, CUSTOM, etc.)
searchResults
StateFlow<List<Word>>
DAO query
FTS4 search results
globalSearchResult
StateFlow<Word?>
AI import + DAO
Result from global search/AI import
isGlobalSearching
StateFlow<Boolean>
Operation flag
Loading state for global search
importLogs
StateFlow<List<String>>
Operation logs
Real-time logs for bulk import/export
isImporting
StateFlow<Boolean>
Operation flag
Loading state for import operations
Test & Session State
StateFlow
Type
Purpose
testType
StateFlow<TestType>
CHOICE or SPELL mode selection
testCandidates
StateFlow<List<Word>?>
Words selected for testing
testSession
StateFlow<TestSession?>
Active test session (persisted to DB)
testHistory
Flow<List<TestHistory>>
All completed test records
Online Library State
StateFlow
Type
Purpose
onlineLibraries
StateFlow<List<OnlineLibrary>>
Paginated list of online libraries
onlineTags
StateFlow<List<Pair<String, Int>>>
Available tags and counts
isNetworkLoading
StateFlow<Boolean>
Network operation status
Additional State
StateFlow
Type
Purpose
allLibraries
Flow<List<Library>>
All local libraries (direct DAO Flow)
allWordLists
Flow<List<WordList>>
Custom word list collections
currentWordListId
StateFlow<Int>
Active word list selection
pendingJumpWordId
StateFlow<Int?>
Cross-library navigation target
isTtsReady
StateFlow<Boolean>
Text-to-speech engine status
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-181
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
468-490
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
68-77
Derived Flow Construction
The ViewModel uses Kotlin Flow operators to create reactive, derived state. Two critical patterns are employed:
Pattern 1: Combined State with flatMapLatest
The
allWords
Flow combines two independent StateFlows (
currentLibraryId
and
sortOption
) and triggers a new database query whenever either changes:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
Pattern 2: Multi-Source Flow Composition
The
dueWords
Flow supports selecting multiple libraries for study. It defaults to the current library if no study libraries are selected:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
Core Operations by Domain
Library Management Operations
The ViewModel provides full CRUD operations for libraries, with automatic current library switching and study selection validation.
Key Functions:
switchLibrary(libraryId: Int)
: Updates
_currentLibraryId
and persists to SharedPreferences
addLibrary(name: String)
: Creates new library via
WordDao.insertLibrary()
deleteLibrary(libraryId: Int)
: Deletes all words in library, then library itself; switches to library 1 if current is deleted
renameLibrary(libraryId: Int, newName: String)
: Fetches library, updates name via DAO insert with REPLACE strategy
toggleStudyLibrary(libraryId: Int)
: Adds/removes library from study selection set
setStudyLibraries(ids: Set<Int>)
: Replaces entire study selection
State Validation:
On initialization, the ViewModel validates
_studyLibraryIds
against actual libraries in the database, filtering out invalid IDs to prevent orphaned references.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
184-199
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
398-401
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
442-460
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
201-233
Word CRUD Operations
Basic Operations:
updateWord(word: Word)
: Single word update via DAO
deleteWord(word: Word)
: Single word deletion
deleteWords(ids: List<Int>)
: Batch deletion by IDs
updateWords(words: List<Word>)
: Batch update for reordering; automatically switches to
SortOption.CUSTOM
Search Operations:
searchWords(query: String)
: Invokes
WordDao.searchWords()
which uses FTS4 for full-text search, updates
_searchResults
handleGlobalSearch(query: String)
: Global exact match search; if found, marks as "forgotten" (quality 0 review); if not found, triggers AI import via
importSingleWord()
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
529-567
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
383-396
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
282-306
SM-2 Algorithm Implementation
The
processReview()
function implements the SuperMemo-2 spaced repetition algorithm. Quality ratings range from 0 (Blackout) to 5 (Perfect).
Algorithm Logic:
Quality
Action
Repetitions
Interval Calculation
Easiness Factor Update
< 3
Reset
0
1 day
Unchanged
≥ 3
Advance
+1
I(1)=1, I(2)=6, I(n)=I(n-1)*EF
EF' = EF + (0.1 - (5-q)*(0.08 + (5-q)*0.02)), min 1.3
Word Updates:
nextReviewTime
: currentTimeMillis + (interval * 86400000ms)
lastReviewTime
: currentTimeMillis
reviewCount
: +1
correctCount
: +1 if quality ≥ 3
incorrectCount
: +1 if quality < 3
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
AI Integration Operations
Single Word Import
The
importSingleWord()
function is called when global search finds no existing word. It sends a structured prompt to the AI API requesting a standardized JSON format.
AI Response Format:
word
: Lemma/root form (e.g., "run" for "ran")
phonetic
: IPA pronunciation
senses
: Object with keys like "sense_1", "sense_2" containing
pos
and
meaning
definition_en
: Brief English definition
example
: Bilingual example sentence
memory_method
: Mnemonic technique
forms
: Grammatical variations (past, participle, plural, third_person)
Process Flow:
Construct AI prompt with strict JSON rules
Send request via
RetrofitClient.api.chat()
Extract JSON from response (handles markdown wrapping)
Parse into
StandardizedWord
object
Convert to
Word
entity with
toEntity()
extension
Insert into target library (AppConfig.saveLocationId or current)
Update
_globalSearchResult
StateFlow
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
308-380
Bulk Import Pipeline
The
bulkImport()
function implements a sophisticated multi-stage AI pipeline with retry logic and parallel processing. It processes long text passages to extract and define vocabulary words.
Pipeline Stages:
Key Features:
Phrase Handling:
Spaces in phrases replaced with underscores during extraction, then restored after AI definition
Chunked Processing:
Words processed in batches of 3 to prevent AI timeout
Retry Queue:
Failed chunks re-queued up to 3 times with
ArrayDeque<Pair<List<String>, Int>>
Concurrency:
Up to 3 batches processed in parallel using
async
and
awaitAll()
Synchronized Set:
Collections.synchronizedSet()
tracks imported words to prevent race conditions
Real-time Logging:
_importLogs
StateFlow updated throughout pipeline for UI progress display
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-815
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
817-865
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
867-917
Import/Export Operations
Export Library
The
exportLibrary()
function supports exporting single or multiple libraries to JSON files.
Export Format (
ExportPackage
):
Process:
Determine target library IDs (provided list or current)
Fetch each library metadata and words via
WordDao.getLibraryById()
and
WordDao.getWordsByLibraryList()
Construct
ExportPackage
with
LibraryExportData
entries
Serialize to JSON with Gson
Write to external storage:
context.getExternalFilesDir(null)/magicword_export_{id}_{timestamp}.json
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
582-622
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
625-641
Import Library
The
importLibraryJson()
function handles two formats: new
ExportPackage
format and legacy word list format.
Import Logic:
Try New Format:
Parse as
ExportPackage
; if successful, create new libraries for each entry, insert words with new library IDs
Fallback to Legacy:
Parse as
List<Word>
; insert all words into current library
Update
_importLogs
with detailed progress
Conflict Resolution:
New libraries are created for each imported library to avoid ID conflicts. Words are inserted with
id = 0
to let Room auto-generate new IDs.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
644-696
Test Management Operations
The ViewModel manages quiz sessions with persistence support for mid-session app closure.
Test Session Lifecycle:
Key Functions:
setTestType(type: TestType)
: Select CHOICE or SPELL mode
setTestCandidates(words: List<Word>?)
: Set available words for testing
saveTestSession(session: TestSession)
: Persist current session to DB (called frequently during test)
clearTestSession()
: Remove persisted session after completion
saveTestResult(history: TestHistory)
: Record completed test in history table
updateWordStats(wordId: Int, isCorrect: Boolean)
: Update word's correctCount/incorrectCount
Session Restoration:
In the
init
block, the ViewModel loads any existing
TestSession
with ID 1, allowing seamless continuation after app restart.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
468-527
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
493-496
Online Library Operations
The ViewModel interfaces with the Cloudflare Worker API to browse, search, download, and upload community vocabulary libraries.
Fetching Online Libraries
The
fetchOnlineLibraries()
function implements paginated loading with client-side filtering.
Index Structure:
num.json
: Contains
totalPages
metadata
index_0.json
,
index_1.json
, ...: Paginated library entries
Pagination Logic:
On refresh (
isRefresh=true
), reset
currentPage=0
and clear
_onlineLibraries
Fetch
num.json
to determine
totalPages
Iterate through index pages until
BATCH_SIZE
(10) items found or end reached
Apply local filtering for search query and tag selection
Append results to
_onlineLibraries
StateFlow
Auto-load next page if filtered result < 10 items (max 5 attempts per
loadMoreOnlineLibraries()
call)
Search/Filter State:
currentSearchQuery
: Name/description text match (case-insensitive)
currentSearchTag
: Tag exact match (case-insensitive)
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1022-1114
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1016-1020
Uploading Libraries
The
uploadLibraryPackage()
function uploads local libraries to the community catalog.
Upload Process:
Generate JSON via
getLibraryJson(libraryIds)
Base64 encode content:
android.util.Base64.encodeToString()
Construct JSON request body with
name
,
description
,
tags
,
contentBase64
POST to
https://mag.upxuu.com/library/upload
On success, refresh online library list
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1116-1158
Downloading Libraries
The
downloadAndImportLibrary()
function fetches a library's JSON from its
downloadUrl
and imports it via
importLibraryJson()
.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1160-1185
Tags Management
The
fetchOnlineTags()
function loads
tags.json
which contains tag names and their usage counts for UI filtering.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
993-1014
Word List Operations
Word lists allow users to create custom collections spanning multiple libraries.
Data Model:
WordList
stores library IDs as JSON string (
libraryIdsJson
)
Operations:
createWordList(name: String, libraryIds: List<Int>)
: Serialize IDs to JSON, insert via DAO
deleteWordList(wordList: WordList)
: Delete from DB; clear current selection if deleted
updateWordList(wordList: WordList)
: Update via DAO
setCurrentWordListId(id: Int)
: Switch active word list, persist to SharedPreferences
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
927-961
Text-to-Speech Operations
The ViewModel manages a
TextToSpeech
engine instance for word pronunciation.
Initialization:
initTts(context: Context)
: Initializes TTS with
Locale.US
, sets speech rate to 0.9x for clarity
Updates
_isTtsReady
StateFlow based on initialization result
Usage:
speak(text: String)
: Speaks text if engine is ready and text is non-blank
QUEUE_FLUSH
mode ensures new speech interrupts previous
Lifecycle:
onCleared()
: Stops and shuts down TTS engine to release resources
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
74-110
Navigation Operations
The ViewModel supports cross-library navigation for jumping to specific words.
Jump Flow:
jumpToWord(libraryId: Int, wordId: Int)
: Switches to target library, sets
_pendingJumpWordId
UI screen observes
pendingJumpWordId
, scrolls to target word when non-null
UI calls
clearPendingJump()
after navigation complete
This pattern decouples navigation intent from UI rendering, allowing the screen to handle the actual scroll/focus logic.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
963-980
Integration Points
WordDao Integration
The ViewModel invokes
WordDao
methods for all database operations. Key methods used:
DAO Method
Usage in ViewModel
getWordsByLibrary(libraryId)
Reactive Flow for
allWords
getDueWordsForLibraries(ids, time)
Reactive Flow for
dueWords
searchWords(query)
FTS4 full-text search
findWordGlobal(word)
Global exact match
insertWord(word)
Single word insertion
updateWord(word)
Single word update
deleteWord(word)
/
deleteWordById(id)
Word deletion
getAllLibraries()
Reactive Flow for library list
insertLibrary(library)
Create/update library
deleteLibrary(id)
/
deleteWordsByLibrary(id)
Library deletion cascade
getLibraryById(id)
Fetch library metadata
getWordsByLibraryList(id)
Non-Flow word list for export
insertTestHistory(history)
/
getAllTestHistory()
Test persistence
saveTestSession(session)
/
getTestSession(id)
/
clearTestSession(id)
Session management
updateWordStats(wordId, correctDelta)
Update test statistics
insertWordList(wordList)
/
updateWordList(wordList)
/
deleteWordList(wordList)
/
getAllWordLists()
Word list CRUD
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-66
SharedPreferences Integration
The ViewModel uses
SharedPreferences
for lightweight persistence of UI state that survives app restarts but doesn't require database complexity.
Stored Keys:
Key
Type
Purpose
current_library_id
Int
Active library selection
sort_option
String (enum)
Sort mode name
study_library_ids
StringSet
Set of library IDs for study
current_word_list_id
Int
Active word list selection
last_index_{libraryId}
Int
Last viewed index per library
Pattern:
StateFlows are initialized from prefs, and updated via
prefs.edit().putXXX().apply()
whenever the StateFlow changes.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-168
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
217-219
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
255-267
RetrofitClient Integration
The ViewModel uses
RetrofitClient.api
for AI API calls. The client is configured globally in the network layer with base URL and authentication.
API Calls:
RetrofitClient.api.chat(AiRequest)
: Sends messages to AI model, returns structured response
Request Structure:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
17-19
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
344-346
OkHttpClient Integration
The ViewModel maintains its own
OkHttpClient
instance for direct HTTP calls to the Cloudflare Worker API.
Usage:
Fetching paginated index files (
index_X.json
,
num.json
,
tags.json
)
Downloading library JSON from online catalog
Uploading libraries via POST to
/library/upload
Pattern:
Requests are built with
Request.Builder().url().build()
, executed with
client.newCall(request).execute()
on
Dispatchers.IO
.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
65-66
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
996-1009
AppConfig Integration
The ViewModel reads global configuration from
AppConfig
singleton:
Config Property
Usage
modelName
AI model selection for requests
saveLocationId
Target library for imported words (overrides current if > 0)
userPersona
Contextual hint for AI to personalize examples/mnemonics
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
49
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
338
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
358
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
868-871
Factory Pattern
The
LibraryViewModelFactory
implements
ViewModelProvider.Factory
to inject dependencies into the ViewModel. This is necessary because ViewModels with constructor parameters cannot be instantiated by the default ViewModelProvider.
Usage Pattern in UI:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1188-1196
Lifecycle Management
The
LibraryViewModel
extends Android's
ViewModel
, providing lifecycle-aware state management:
Lifecycle Hooks:
init
block: Validates study library IDs, restores test session from database
onCleared()
: Releases TTS resources (stop and shutdown)
Coroutine Scope:
All asynchronous operations launch in
viewModelScope
, which is automatically cancelled when the ViewModel is cleared, preventing memory leaks.
Persistence Guarantees:
StateFlows survive configuration changes (screen rotation)
SharedPreferences survive app restart
Room database survives app restart and device reboot
TestSession table enables mid-test app closure recovery
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
184-199
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
493-496
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
106-110
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
LibraryViewModel - Central State Manager
Purpose and Scope
Architecture Overview
State Management System
Primary StateFlows
Test & Session State
Online Library State
Additional State
Derived Flow Construction
Pattern 1: Combined State with flatMapLatest
Pattern 2: Multi-Source Flow Composition
Core Operations by Domain
Library Management Operations
Word CRUD Operations
SM-2 Algorithm Implementation
AI Integration Operations
Single Word Import
Bulk Import Pipeline
Import/Export Operations
Export Library
Import Library
Test Management Operations
Online Library Operations
Fetching Online Libraries
Uploading Libraries
Downloading Libraries
Tags Management
Word List Operations
Text-to-Speech Operations
Navigation Operations
Integration Points
WordDao Integration
SharedPreferences Integration
RetrofitClient Integration
OkHttpClient Integration
AppConfig Integration
Factory Pattern
Lifecycle Management

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.1.2-data-layer-and-persistence

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Data Layer & Persistence
Relevant source files
app/src/main/java/com/magicword/app/data/ExportModels.kt
app/src/main/java/com/magicword/app/data/TestSession.kt
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/TestScreen.kt
error.txt
Purpose and Scope
This document describes the data persistence architecture of the MagicWord Android application. It covers the Room database structure, entity definitions, data access objects (DAOs), SharedPreferences usage, and data flow patterns. For information about how the LibraryViewModel coordinates these data operations, see
LibraryViewModel - Central State Manager
. For details on how data synchronizes with cloud infrastructure, see
Cloud Infrastructure
.
The data layer implements a
three-tier persistence hierarchy
:
Temporary
: In-memory state managed by Compose
rememberSaveable
for configuration changes
Lightweight
: SharedPreferences for settings and simple key-value pairs
Durable
: Room SQLite database for structured, queryable data
Database Architecture Overview
The application uses Room as the persistence library, providing an abstraction layer over SQLite with compile-time SQL validation and Kotlin Coroutines/Flow integration.
Database Component Structure
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63
app/src/main/java/com/magicword/app/ui/TestScreen.kt
84-85
Entity Overview Table
Entity
Table Name
Primary Key
Purpose
Key Relationships
Word
words
id
(auto-increment)
Stores vocabulary entries with SM-2 metadata
References
Library
via
libraryId
Library
libraries
id
(auto-increment)
Groups words into collections
Parent of
Word
entities
TestSession
test_session
id
(default 1)
Persists in-progress test state
Stores
libraryId
for context
TestHistory
test_history
id
(auto-increment)
Records completed test results
Stores
questionsJson
array
WordList
word_lists
id
(auto-increment)
Custom word groupings/tags
Many-to-many with
Word
word_fts
word_fts
(FTS4 rowid)
Full-text search virtual table
Mirrors
Word.word
field
Sources:
app/src/main/java/com/magicword/app/data/TestSession.kt
6-15
Core Entities
Word Entity
The
Word
entity is the central data structure, storing vocabulary items with spaced repetition metadata, definitions, and usage statistics.
Word Schema
Key Fields:
Field
Type
Purpose
sensesJson
String
JSON-encoded map of word meanings (e.g.,
{"sense_1": {"pos": "n", "meaning": "含义"}}
)
formsJson
String
JSON-encoded word variations (past, participle, plural, third_person)
repetitions
Int
SM-2 algorithm: consecutive correct reviews
interval
Int
SM-2 algorithm: days until next review
easinessFactor
Float
SM-2 algorithm: difficulty modifier (default 2.5)
nextReviewTime
Long
Unix timestamp (ms) when word is due for review
sortOrder
Int
Custom ordering for
SortOption.CUSTOM
mode
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
(SM-2 processing),
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
(sorting)
Library Entity
The
Library
entity represents a named collection of words. The application supports multiple libraries with independent word sets.
Schema:
Special Considerations:
Library with
id = 1
is the default library and cannot be deleted
lastIndex
tracks user's position in card-based review mode
Deletion cascade: deleting a library removes all associated words
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
448-459
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
99
Test-Related Entities
TestSession Entity
Persists in-progress test state to allow resumption after app restart or tab switch.
Persistence Flow:
Save
: On every question answered
app/src/main/java/com/magicword/app/ui/TestScreen.kt
146-161
Restore
: On app launch or TestScreen composition
app/src/main/java/com/magicword/app/ui/TestScreen.kt
123-143
Clear
: When test finishes
app/src/main/java/com/magicword/app/ui/TestScreen.kt
219
Sources:
app/src/main/java/com/magicword/app/data/TestSession.kt
6-15
app/src/main/java/com/magicword/app/ui/TestScreen.kt
120-163
TestHistory Entity
Records completed test results for historical analysis.
Key Fields:
totalQuestions
: Total number of questions in test
correctCount
: Number of correct answers
testType
: "CHOICE" or "SPELL"
durationSeconds
: Test completion time
questionsJson
: JSON array of
TestResultItem
objects containing per-question details
timestamp
: Test completion time (auto-generated)
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
211-219
app/src/main/java/com/magicword/app/ui/TestScreen.kt
283-293
Data Access Objects (DAOs)
WordDao Interface
The
WordDao
consolidates all database operations into a single interface. It provides methods for word CRUD operations, library management, test persistence, and full-text search.
Core Query Methods
Key Query Patterns:
Method
SQL Pattern
Use Case
Sources
getWordsByLibrary()
SELECT * FROM words WHERE libraryId = ?
Display all words in current library
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
getDueWordsForLibraries()
SELECT * FROM words WHERE libraryId IN (?) AND nextReviewTime < ?
Fetch words due for SM-2 review
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
searchWords()
SELECT * FROM word_fts WHERE word_fts MATCH ?
Full-text search across all words
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
383-396
findWordGlobal()
SELECT * FROM words WHERE word = ? LIMIT 1
Exact match lookup for global search
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
289
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
8
FTS4 Full-Text Search
The database includes a virtual
word_fts
table using SQLite's FTS4 (Full-Text Search) extension for efficient substring matching.
Configuration:
Characteristics:
Content Table
: Mirrors the
word
field from the
words
table
Tokenization
: Default simple tokenizer (space-separated)
Search Syntax
: Supports prefix matching (e.g.,
"appl*"
matches "apple", "application")
Performance
: Optimized for
LIKE '%query%'
patterns without full table scan
Query Example:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
383-396
Library Management Methods
Method
Return Type
Purpose
getAllLibraries()
Flow<List<Library>>
Reactive list for library dropdown/manager
getLibraryById(id)
Library?
Synchronous lookup for export operations
getAllLibrariesSnapshot()
List<Library>
One-shot fetch for validation
insertLibrary(library)
Long
Create/update library (REPLACE conflict strategy)
deleteLibrary(id)
Unit
Remove library (cascade delete words separately)
updateLibraryLastIndex(id, index)
Unit
Persist card scroll position
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
440
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
535-542
Test Persistence Methods
Method
Purpose
Invocation Context
saveTestSession(session)
Persist current test state
Every question answer
TestScreen.kt
157
getTestSession(id)
Restore test on launch
TestScreen initialization
TestScreen.kt
495
clearTestSession(id)
Remove saved state
Test completion
TestScreen.kt
219
insertTestHistory(history)
Record completed test
Test finish callback
TestScreen.kt
218
getAllTestHistory()
Flow<List<TestHistory>>
Test history screen
TestScreen.kt
235
updateWordStats(wordId, correct)
Update
correctCount
/
incorrectCount
Per-question result
TestScreen.kt
223-225
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
499-527
app/src/main/java/com/magicword/app/ui/TestScreen.kt
146-226
SharedPreferences Usage
The application uses SharedPreferences for lightweight, non-relational state that needs fast synchronous access or doesn't fit the database model.
Persisted State Map
Key-Value Storage:
Key Pattern
Type
Purpose
Read Timing
Write Timing
current_library_id
Int
Active library selection
ViewModel init
Library switch
study_library_ids
StringSet
Multi-library review selection
ViewModel init
Library toggle
sort_option
String (enum)
Word list sort order
ViewModel init
Sort change
last_index_{libraryId}
Int
Card scroll position
Screen composition
Card swipe
app_settings
(File name)
SharedPreferences file identifier
Context access
N/A
Hybrid Persistence Pattern:
The
lastIndex
field demonstrates a dual-persistence strategy:
Fast Path
: Write to SharedPreferences immediately on card swipe for instant recall
LibraryViewModel.kt
537
Durable Path
: Asynchronously sync to
Library.lastIndex
in database
LibraryViewModel.kt
540
Recovery
: On init, database is source of truth, falling back to prefs if needed
LibraryViewModel.kt
545-553
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-219
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
255-267
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
535-553
Data Flow Patterns
Reactive StateFlow Architecture
The data layer integrates with the ViewModel via Kotlin Flow operators, creating reactive data streams that automatically update UI on database changes.
Flow Operator Chain Example:
The
allWords
flow demonstrates a multi-source reactive pipeline
LibraryViewModel.kt
404-418
:
Flow Composition Patterns:
Pattern
Operator(s)
Use Case
Example
Multi-Source Reactive
combine()
+
flatMapLatest()
Query depends on multiple upstream StateFlows
Due words filter: combines
currentLibraryId
+
studyLibraryIds
+ current time
Query Switching
flatMapLatest()
Cancel previous query when parameter changes
Library switch cancels old word fetch
Derived Data
map()
Transform database results client-side
Sorting word lists without database query
Filter + Transform
map()
+ conditional logic
Computed state from raw data
Filter words reviewed in last 24h
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-418
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
Persistence Strategy Decision Tree
Decision Criteria:
Use Room Database when:
Data has relationships (e.g., Word ↔ Library)
Complex queries needed (search, filtering, sorting)
Data must be reactive (Flow-based UI updates)
Multi-table operations required
Use SharedPreferences when:
Simple key-value pairs
Fast synchronous access required
Settings/configuration data
Non-relational data < 1KB per entry
Use In-Memory State when:
Temporary UI state (selection, dialogs)
Derived/computed values
Transient error messages
Animation/transition state
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-181
app/src/main/java/com/magicword/app/ui/TestScreen.kt
94-96
Export and Import Data Models
The application defines specialized data classes for JSON serialization during library export/import and online library operations.
Export Package Structure
Model Definitions:
Export Flow
LibraryViewModel.kt
582-622
:
Target Selection
: Accept
libraryIds
parameter (defaults to current library)
Data Aggregation
: For each library, fetch
Library
metadata + all
Word
entities
Package Construction
: Wrap in
ExportPackage
with version metadata
Serialization
: Use Gson to convert to JSON string
File Writing
: Save to
context.getExternalFilesDir()
with timestamped filename
Import Flow
LibraryViewModel.kt
644-696
:
Parse JSON
: Attempt to deserialize as
ExportPackage
(new format)
Fallback
: If parsing fails, try legacy
List<Word>
format
Library Creation
: For each
LibraryExportData
, insert new
Library
entity
Word Migration
: Insert each word with
libraryId
updated to new library ID,
id
reset to 0 (auto-generate)
Logging
: Emit import progress to
importLogs
StateFlow
Sources:
app/src/main/java/com/magicword/app/data/ExportModels.kt
1-19
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
582-696
Online Library Model
The
OnlineLibrary
data class represents a library entry from the GitHub-hosted index.
Lifecycle:
Index Fetch
: Downloaded from
mag.upxuu.com/library/index_{page}.json
LibraryManagerScreen.kt
202-205
Display
: Shown in OnlineLibraryTab with tag chips
LibraryManagerScreen.kt
350-413
Download
: On button click, fetches library.json from
downloadUrl
referenced in LibraryViewModel
Import
: Parses as
ExportPackage
and inserts into local database
Sources:
app/src/main/java/com/magicword/app/data/ExportModels.kt
22-32
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
191-346
Database Migration Strategy
Note: The provided code does not show explicit migration logic. The following describes typical Room migration patterns that should be implemented.
Current Approach:
The
AppDatabase
likely uses:
Recommended Migration Implementation:
For schema changes (adding columns, creating tables, etc.), Room requires
Migration
objects:
Sources:
Inferred from Room best practices; no explicit migration code found in provided files.
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Data Layer & Persistence
Purpose and Scope
Database Architecture Overview
Database Component Structure
Entity Overview Table
Core Entities
Word Entity
Word Schema
Library Entity
Test-Related Entities
TestSession Entity
TestHistory Entity
Data Access Objects (DAOs)
WordDao Interface
Core Query Methods
FTS4 Full-Text Search
Library Management Methods
Test Persistence Methods
SharedPreferences Usage
Persisted State Map
Data Flow Patterns
Reactive StateFlow Architecture
Persistence Strategy Decision Tree
Export and Import Data Models
Export Package Structure
Online Library Model
Database Migration Strategy

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.1.3-build-configuration

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Build Configuration
Relevant source files
app/build.gradle.kts
Purpose and Scope
This document details the Gradle build configuration for the MagicWord Android application. It covers the plugin architecture, compilation settings, signing configuration for CI/CD environments, build variants, and dependency management. The build configuration enables reproducible builds across development and CI/CD environments while supporting both local and automated release signing.
For information about the CI/CD pipeline that uses this configuration, see
CI/CD Pipeline
. For details on the release process, see
Release Process
.
Build System Overview
MagicWord uses
Gradle with Kotlin DSL
(
build.gradle.kts
) for its build configuration. The build system is configured through five Gradle plugins that enable Android development, Kotlin compilation, annotation processing, and data class serialization.
Plugin Architecture
Diagram: Plugin Dependency Chain
The plugin configuration at
app/build.gradle.kts
1-6
establishes the build pipeline:
Plugin
Purpose
Key Functionality
com.android.application
Core Android build plugin
APK/AAB generation, resource processing, manifest merging
org.jetbrains.kotlin.android
Kotlin language support
Kotlin compilation, coroutines, extensions
com.google.devtools.ksp
Kotlin Symbol Processing
Room database code generation, faster than kapt
kotlin-parcelize
Parcelable serialization
Automatic Parcelable implementation for data classes
Sources:
app/build.gradle.kts
1-6
Android Configuration
The
android
block defines SDK requirements, application identity, and versioning strategy.
Diagram: Android Configuration Hierarchy
SDK Level Requirements
The configuration at
app/build.gradle.kts
8-23
establishes the following SDK boundaries:
compileSdk = 34
: Compile-time API level (Android 14), determines available APIs during compilation
targetSdk = 34
: Runtime behavior target, indicates the app is tested against Android 14 features
minSdk = 24
: Minimum supported version (Android 7.0 Nougat), approximately 99% device coverage as of 2024
Application Identity
namespace
: Package name for R class generation, set to
com.magicword.app
at
app/build.gradle.kts
9
applicationId
: Unique identifier for app stores, also
com.magicword.app
at
app/build.gradle.kts
13
Versioning Scheme
The application uses a dual-versioning scheme at
app/build.gradle.kts
16-17
:
versionCode = 22
: Monotonically increasing integer for update ordering (current: 22)
versionName = "0.0.21"
: Semantic version string displayed to users
Version increments are manual and coordinated with release tagging in GitHub.
Sources:
app/build.gradle.kts
8-23
Signing Configuration
MagicWord implements a
dual-mode signing system
that supports both local development and CI/CD environments. The configuration automatically detects environment variables and falls back to defaults for local builds.
Signing Configuration Flow
Diagram: Signing Configuration Resolution
Configuration Details
The signing configuration at
app/build.gradle.kts
25-35
implements environment-variable-based credential injection:
Configuration Property
Environment Variable
Default Fallback
Purpose
storeFile
KEYSTORE_PATH
release.jks
Path to keystore file
storePassword
STORE_PASSWORD
password
Keystore password
keyAlias
KEY_ALIAS
alias
Key alias within keystore
keyPassword
KEY_PASSWORD
password
Key password
CI/CD Integration
In GitHub Actions workflows, the keystore file is decoded from a base64-encoded secret and written to
app/release.jks
. The environment variables are then set from GitHub Secrets before invoking Gradle. See the comment at
app/build.gradle.kts
27
for expected behavior.
The
release
build type at
app/build.gradle.kts
37-45
applies this signing configuration and disables ProGuard minification (line 40).
Sources:
app/build.gradle.kts
25-35
app/build.gradle.kts
37-45
Build Types and Variants
MagicWord defines two build types with distinct signing and optimization behaviors:
Diagram: Build Type Configuration
Release Build Type
Configured at
app/build.gradle.kts
38-45
:
Signing
: Uses the
release
signing configuration for production credentials
Minification
: Disabled (
isMinifyEnabled = false
) at line 40, simplifying debugging while maintaining performance
ProGuard
: Rules defined but not actively minifying, reserved for future optimization
Output
: Produces signed APK suitable for distribution via GitHub Releases
Debug Build Type
Configured at
app/build.gradle.kts
46-48
:
Signing
: Uses default Android debug keystore
Note
: Lines 47 contains a commented option to use release signing for debug builds if needed
Output
: Produces unsigned or debug-signed APK for development
Sources:
app/build.gradle.kts
37-48
Compilation Settings
The build configuration specifies compilation targets and feature flags that determine language level and UI framework capabilities.
Java and Kotlin Compatibility
Diagram: Compilation Target Configuration
Configured at
app/build.gradle.kts
50-56
:
Java Compatibility
: Source and target set to Java 8 (lines 51-52)
Kotlin JVM Target
: Also set to Java 8 (line 55)
Rationale
: Java 8 provides modern language features (lambdas, streams) while maintaining compatibility with
minSdk = 24
Build Features
The
buildFeatures
block at
app/build.gradle.kts
57-60
enables framework capabilities:
Feature
Value
Purpose
compose
true
Enables Jetpack Compose UI framework
buildConfig
true
Generates
BuildConfig
class with version info
Compose Configuration
The
composeOptions
block at
app/build.gradle.kts
61-63
specifies:
kotlinCompilerExtensionVersion = "1.5.4"
: Compose compiler version, must match Kotlin compiler version
Compatibility
: This version is compatible with Kotlin 1.9.x
Packaging Options
The
packaging
block at
app/build.gradle.kts
64-68
excludes duplicate license files to avoid build conflicts:
Sources:
app/build.gradle.kts
50-68
Dependencies
MagicWord's dependency graph includes UI frameworks, persistence libraries, networking clients, and utility libraries. All dependencies are declared in the
dependencies
block at
app/build.gradle.kts
71-107
Dependency Architecture
Diagram: Dependency Graph
Core Dependencies by Category
UI Framework (AndroidX + Jetpack Compose)
Dependency
Version
Purpose
core-ktx
1.12.0
Kotlin extensions for Android framework
lifecycle-runtime-ktx
2.6.2
Lifecycle-aware coroutines, ViewModel support
activity-compose
1.8.1
Compose integration with Activity
compose-bom
2023.08.00
Bill of Materials for Compose versioning
material3
(via BOM)
Material Design 3 components
material-icons-extended
(via BOM)
Full Material icon set
navigation-compose
2.7.5
Compose navigation framework
Declared at
app/build.gradle.kts
73-82
Data Persistence (Room)
Dependency
Version
Configuration
Purpose
room-runtime
2.6.1
implementation
Core Room database runtime
room-ktx
2.6.1
implementation
Kotlin coroutines extensions
room-compiler
2.6.1
ksp
Annotation processor for DAO/Entity code generation
Declared at
app/build.gradle.kts
84-88
Note the use of
ksp
instead of
kapt
for faster compilation.
Network Layer (Retrofit)
Dependency
Version
Purpose
retrofit
2.9.0
HTTP client abstraction
converter-gson
2.9.0
JSON serialization using Gson
Declared at
app/build.gradle.kts
90-92
Used for AI API integration and GitHub proxy communication.
Utility Libraries
Dependency
Version
Purpose
work-runtime-ktx
2.9.0
Background task scheduling (WorkManager)
reorderable
2.4.3
Drag-and-drop reordering for LazyColumn
Declared at
app/build.gradle.kts
94-98
Test Dependencies
The configuration includes standard Android testing dependencies at
app/build.gradle.kts
100-106
:
Unit Testing
:
junit:4.13.2
Instrumentation Testing
:
androidx.test.ext:junit
,
espresso-core
Compose Testing
:
ui-test-junit4
,
ui-test-manifest
Debug Tooling
:
ui-tooling
for Compose preview
Sources:
app/build.gradle.kts
71-107
Build Outputs and Artifacts
The build configuration produces the following artifacts based on build type:
Release Build
Command
:
./gradlew assembleRelease
Output
:
app/build/outputs/apk/release/app-release.apk
Characteristics
:
Signed with production keystore
ProGuard rules defined but minification disabled
Version name embedded in BuildConfig
Suitable for GitHub Release distribution
Debug Build
Command
:
./gradlew assembleDebug
Output
:
app/build/outputs/apk/debug/app-debug.apk
Characteristics
:
Signed with debug keystore
No optimization
Includes debug symbols
Suitable for development and testing
Configuration Management
Version Management
Version updates require manual edits to
app/build.gradle.kts
16-17
:
Increment
versionCode
by 1 (currently 22)
Update
versionName
following semantic versioning (currently "0.0.21")
Commit changes with version tag matching
versionName
Trigger CI/CD to build and release
Dependency Updates
Dependencies should be reviewed periodically for security updates and new features. Special considerations:
Compose BOM
: Updates may require
kotlinCompilerExtensionVersion
changes
Room
: Verify KSP compatibility when updating
Kotlin
: Must maintain compatibility with Compose compiler
Environment-Specific Configuration
For local builds, developers can either:
Use default values (insecure, for development only)
Create a
local.properties
file with signing credentials (not recommended)
Set environment variables matching CI/CD names
For CI/CD builds, GitHub Secrets must contain:
KEYSTORE_BASE64
: Base64-encoded keystore file
STORE_PASSWORD
: Keystore password
KEY_ALIAS
: Key alias
KEY_PASSWORD
: Key password
Sources:
app/build.gradle.kts
1-107
Summary
The MagicWord build configuration implements a modern Android build system with the following characteristics:
Kotlin DSL
: Type-safe build configuration with IDE support
Plugin Architecture
: Four plugins (Android, Kotlin, KSP, Parcelize) enable code generation and compilation
Dual-Mode Signing
: Environment variable detection supports both local and CI/CD builds
Modern SDK Targets
: Targets Android 14 (API 34) while supporting Android 7.0+ (API 24)
Jetpack Compose
: Full Compose UI framework with Material 3 components
Room Database
: KSP-based code generation for database abstractions
Retrofit Networking
: Type-safe HTTP client for AI and GitHub API integration
Reproducible Builds
: Version-locked dependencies and explicit signing configuration
The configuration is designed to support automated GitHub Actions workflows while remaining accessible for local development.
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Build Configuration
Purpose and Scope
Build System Overview
Plugin Architecture
Android Configuration
SDK Level Requirements
Application Identity
Versioning Scheme
Signing Configuration
Signing Configuration Flow
Configuration Details
CI/CD Integration
Build Types and Variants
Release Build Type
Debug Build Type
Compilation Settings
Java and Kotlin Compatibility
Build Features
Compose Configuration
Packaging Options
Dependencies
Dependency Architecture
Core Dependencies by Category
UI Framework (AndroidX + Jetpack Compose)
Data Persistence (Room)
Network Layer (Retrofit)
Utility Libraries
Test Dependencies
Build Outputs and Artifacts
Release Build
Debug Build
Configuration Management
Version Management
Dependency Updates
Environment-Specific Configuration
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2-user-interface-screens

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
User Interface Screens
Relevant source files
app/src/main/java/com/magicword/app/ui/MainScreen.kt
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
Purpose and Scope
This page provides an overview of the Android application's user interface layer built with Jetpack Compose. It documents the screen hierarchy, navigation architecture, and state management patterns that govern how users interact with the MagicWord vocabulary learning system.
For detailed documentation of specific screens and their features, see:
Main navigation hub:
MainScreen & Navigation
Vocabulary management:
WordsScreen - Vocabulary Management
Spaced repetition learning:
StudyScreen - Spaced Repetition Review
Quiz functionality:
TestScreen - Quiz Functionality
Library operations:
LibraryManagerScreen - Library Operations
Application settings:
SettingsScreen & Configuration
For the central state management component that powers all screens, see
LibraryViewModel - Central State Manager
.
Navigation Architecture
The application uses a
tab-based navigation pattern
implemented with
HorizontalPager
from Jetpack Compose Foundation. The navigation structure distinguishes between
primary screens
(accessible via bottom navigation) and
overlay screens
(displayed as full-screen modals over the main content).
Navigation Flow Diagram
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
188-196
app/src/main/java/com/magicword/app/ui/MainScreen.kt
207-233
Primary Navigation Implementation
The primary navigation uses
HorizontalPager
with synchronized bottom navigation bar state. Tab switches can be triggered manually via
NavigationBarItem
clicks or programmatically through
pagerState.animateScrollToPage()
.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
237-252
app/src/main/java/com/magicword/app/ui/MainScreen.kt
254-274
Screen
Route
Icon
Index
Purpose
StudyScreen
"study"
Icons.Default.School
0
SM-2 spaced repetition review
WordsScreen
"words"
Icons.Default.Book
1
Vocabulary card/list management
TestScreen
"test"
Icons.Default.CheckCircle
2
Multiple-choice and spelling quizzes
WordListScreen
"list"
Icons.Default.List
3
Custom word list grouping
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
279-284
Overlay System Implementation
Overlays use conditional rendering based on a nullable
currentOverlay
state variable. When non-null, the overlay screen replaces the entire
Scaffold
content, effectively implementing a modal navigation pattern without NavHost.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
208-233
Screen Component Mapping
This diagram maps UI screens to their source files and key composable functions:
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
73-277
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
55-618
State Management Architecture
All UI screens follow a unidirectional data flow pattern where
LibraryViewModel
serves as the single source of truth. Screens observe state via
StateFlow.collectAsState()
and trigger actions through ViewModel function calls.
ViewModel Integration Pattern
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
66-68
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
75-96
Common State Patterns
State Type
Implementation
Example Usage
Database-backed
StateFlow<List<T>>
from DAO
allWords
,
dueWords
,
allLibraries
Derived State
combine()
/
flatMapLatest()
dueWords
combines library selection + review status
UI-only State
remember { mutableStateOf() }
isListMode
,
showSearch
,
editingWord
Persistent UI State
SharedPreferences
via ViewModel
currentLibraryId
, sort options
Loading State
StateFlow<Boolean>
isImporting
,
isGlobalSearching
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
87-96
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-186
Inter-Screen Communication
Screens communicate through the shared
LibraryViewModel
instance rather than direct function calls. This enables decoupled, reactive communication.
Cross-Screen Navigation Mechanisms
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
199-205
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
115-122
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
152-161
Test Candidate Flow
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
249-256
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
620-642
Screen Lifecycle Patterns
Initialization Pattern
Each screen follows a consistent initialization pattern using
LaunchedEffect(Unit)
for one-time setup tasks:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
70-73
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
State Restoration Pattern
Screens restore their last state (e.g., scroll position) using SharedPreferences through the ViewModel:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
449-470
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
472-474
Common UI Components
Mode Switching Pattern
WordsScreen
implements a dual-mode interface (Card/List) using
AnimatedContent
:
Mode
Trigger
Layout Component
Key Features
Card Mode
Default
VerticalPager
Immersive learning, swipe navigation, side list toggle
List Mode
Long-press card / List icon
LazyColumn
with reordering
Batch operations, sorting, selection
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
87
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
378-575
Search Integration
Global search is integrated into the persistent search bar with two behaviors:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
319-362
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
124-150
Dialog Management Pattern
Screens use nullable state variables to control dialog visibility:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
88
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
587-597
System Integration Points
Update System Integration
MainScreen
integrates with
UpdateManager
to check for application updates on launch:
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-98
app/src/main/java/com/magicword/app/ui/MainScreen.kt
127-177
Notice System Integration
The notice system displays announcements fetched from the server on app launch:
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
100-105
app/src/main/java/com/magicword/app/ui/MainScreen.kt
108-125
AI Import Integration
Bulk import functionality uses a
ModalBottomSheet
with real-time log streaming:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
600-616
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
672-726
Screen Responsibilities Summary
Screen
File
Primary Responsibilities
Key State
MainScreen
MainScreen.kt
Navigation coordination, tab management, update/notice handling
pagerState
,
currentOverlay
WordsScreen
WordsScreen.kt
Vocabulary display (card/list), editing, bulk import, search
allWords
,
isListMode
,
selectedWords
StudyScreen
StudyScreen.kt
SM-2 review flashcards, library filtering, progress tracking
dueWords
,
studyLibraryIds
TestScreen
TestScreen.kt
Quiz execution, answer validation, history tracking
testSession
,
testCandidates
WordListScreen
WordListScreen.kt
Custom word grouping, list management
Word selection from library
LibraryManagerScreen
LibraryManagerScreen.kt
Local/online library CRUD, download/upload
allLibraries
,
onlineLibraries
SettingsScreen
SettingsScreen.kt
AI configuration, Key-Kit verification, log access
AppConfig
singleton
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
73-277
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
55-618
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
User Interface Screens
Purpose and Scope
Navigation Architecture
Navigation Flow Diagram
Primary Navigation Implementation
Overlay System Implementation
Screen Component Mapping
State Management Architecture
ViewModel Integration Pattern
Common State Patterns
Inter-Screen Communication
Cross-Screen Navigation Mechanisms
Test Candidate Flow
Screen Lifecycle Patterns
Initialization Pattern
State Restoration Pattern
Common UI Components
Mode Switching Pattern
Search Integration
Dialog Management Pattern
System Integration Points
Update System Integration
Notice System Integration
AI Import Integration
Screen Responsibilities Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2.1-mainscreen-and-navigation

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
MainScreen & Navigation
Relevant source files
app/src/main/java/com/magicword/app/ui/MainScreen.kt
Purpose and Scope
This document describes the
MainScreen
composable, which serves as the primary navigation hub and entry point for the MagicWord Android application. It orchestrates tab-based navigation between four main feature screens, manages overlay screens (settings, library manager, profile), and handles critical initialization tasks including update checks and system notices.
For details about individual feature screens accessible through MainScreen, see:
StudyScreen
for spaced repetition review
WordsScreen
for vocabulary management
TestScreen
for quiz functionality
LibraryManagerScreen
for library operations
SettingsScreen
for configuration
For information about the central state management layer that MainScreen integrates with, see
LibraryViewModel
.
Architecture Overview
MainScreen implements a
two-layer navigation pattern
: a primary tab-based horizontal pager for main features, and a modal overlay system for auxiliary screens. The composable manages initialization side effects (update checks, notices) and serves as the integration point between UI and business logic layers.
Component Structure
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
1-285
Navigation Structure
Tab-Based Primary Navigation
MainScreen uses Jetpack Compose's
HorizontalPager
to implement swipeable tab navigation. Four tabs are defined via the sealed
Screen
class:
Index
Route
Label
Icon
Screen Component
0
study
学习
Icons.Default.School
StudyScreen()
1
words
词库
Icons.Default.Book
WordsScreen()
2
test
测试
Icons.Default.CheckCircle
TestScreen()
3
list
单词表
Icons.Default.List
WordListScreen()
The tab order is defined in the
items
list at
MainScreen.kt
191-196
:
Screen Sealed Class
The
Screen
sealed class encapsulates navigation metadata:
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
279-284
Pager Implementation
The navigation is implemented using:
PagerState
: Maintains current page index and handles scroll animations
HorizontalPager
: Renders pages with horizontal swipe gestures
NavigationBar
: Displays bottom tab bar with page selection indicators
The bottom navigation bar is configured at
MainScreen.kt
236-252
where
NavigationBarItem
components observe
pagerState.currentPage
to determine selection state.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
188-196
app/src/main/java/com/magicword/app/ui/MainScreen.kt
236-252
app/src/main/java/com/magicword/app/ui/MainScreen.kt
254-276
Initialization System
MainScreen performs critical initialization tasks on first composition using
LaunchedEffect(Unit)
at
MainScreen.kt
92-106
This ensures update checks and notices are displayed before the user interacts with the app.
Update Check Flow
The update check at
MainScreen.kt
94-98
fetches version information from the server via
UpdateManager.checkUpdate()
. If a newer version is detected, it populates
updateInfo
and sets
showUpdateDialog = true
, triggering the update dialog display.
Notice Check Flow
System notices are checked at
MainScreen.kt
101-105
using
NoticeManager.checkNotice()
. The notice system displays important announcements to users that they haven't yet acknowledged:
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
Dialog Systems
Update Dialog
The update dialog at
MainScreen.kt
127-177
provides a complete update workflow:
State
Components Displayed
Initial
Title:
"New Version Available: v{version}"
Text: Release notes
Buttons: "Update Now" / "Later"
Downloading
Title: Version info
Text: Release notes +
LinearProgressIndicator
Progress: "{downloadProgress}%"
Post-download
Dialog closes, APK installation triggered
The download process uses coroutines at
MainScreen.kt
150-163
:
Notice Dialog
The notice dialog at
MainScreen.kt
108-125
displays announcements from the server. It includes:
Title
:
currentNotice.title
Content
:
currentNotice.content
Action
: "我知道了" button that marks the notice as read
Both dialogs use
onDismissRequest
handlers that prevent dismissal during critical operations (e.g., downloading updates).
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
108-177
Tab Management
Pager Configuration
The
HorizontalPager
is configured with:
pageCount
:
{ 4 }
- Lambda returning the number of tabs
userScrollEnabled
:
true
- Allows swipe gestures
state
:
pagerState
- Manages current page and scroll position
Each page is wrapped in a
SlideInEntry
animation component at
MainScreen.kt
259-273
for smooth transitions.
Tab Switching Mechanisms
There are three ways to switch tabs:
1. User Tap on Navigation Bar
MainScreen.kt
243-249
2. User Swipe Gesture
The
HorizontalPager
with
userScrollEnabled = true
automatically handles swipe gestures.
3. Programmatic Navigation
Child screens can trigger tab switches via callbacks. For example, WordsScreen's
onJumpToTest
callback at
MainScreen.kt
266-268
:
Jump Event Handling
The ViewModel can trigger a jump to the Words tab by setting
pendingJumpWordId
. This is observed at
MainScreen.kt
199-205
:
This mechanism allows deep linking or programmatic navigation from other screens.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
188-205
app/src/main/java/com/magicword/app/ui/MainScreen.kt
236-276
Overlay System
The overlay system provides modal navigation for auxiliary screens without affecting the primary tab navigation state.
Overlay State Machine
Overlay Routing Logic
The routing logic at
MainScreen.kt
210-276
uses conditional rendering based on
currentOverlay
:
Overlay Triggers
Overlays are triggered via callbacks passed to child screens:
Overlay
Triggered By
Callback
Settings
WordsScreen
onOpenSettings = { currentOverlay = "settings" }
Library Manager
WordsScreen
onManageLibraries = { currentOverlay = "library_manager" }
Profile
WordsScreen
onOpenProfile = { currentOverlay = "profile" }
Logs
SettingsScreen
onNavigateToLogs = { currentOverlay = "logs" }
About
SettingsScreen
onNavigateToAbout = { currentOverlay = "about" }
The overlay system provides hierarchical back navigation: Logs and About navigate back to Settings, while Settings navigates back to the main screen (null).
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
207-276
State Management
Local State
MainScreen manages multiple pieces of local state using Compose state primitives:
State Variable
Type
Purpose
isLoggedIn
Boolean
Authentication status from
AuthManager
showUpdateDialog
Boolean
Controls update dialog visibility
updateInfo
UpdateManager.UpdateInfo?
Stores fetched update information
downloadProgress
Int
APK download progress (0-100)
isDownloading
Boolean
Tracks active download state
showNoticeDialog
Boolean
Controls notice dialog visibility
currentNotice
NoticeManager.Notice?
Stores fetched notice data
currentOverlay
String?
Tracks active overlay screen
pagerState
PagerState
Manages tab navigation state
ViewModel Integration
MainScreen integrates with
LibraryViewModel
to access global application state:
The ViewModel is instantiated at
MainScreen.kt
181-183
:
The current library name is derived at
MainScreen.kt
184-186
by combining two StateFlows:
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
76-208
Integration Points
Dependencies
MainScreen depends on several system components:
Child Screen Callbacks
Child screens receive callbacks to interact with MainScreen's overlay system:
WordsScreen Callbacks
MainScreen.kt
263-268
:
onOpenSettings
: Navigates to SettingsScreen overlay
onOpenProfile
: Navigates to ProfileScreen overlay
onManageLibraries
: Navigates to LibraryManagerScreen overlay
onJumpToTest
: Switches tab to TestScreen (index 2)
SettingsScreen Callbacks
MainScreen.kt
212-214
:
onBack
: Closes overlay, returns to main navigation
onNavigateToLogs
: Switches overlay to LogListScreen
onNavigateToAbout
: Switches overlay to AboutScreen
ProfileScreen Callbacks
MainScreen.kt
228-231
:
onBack
: Closes overlay
onLogout
: Updates
isLoggedIn
state and closes overlay
This callback-based architecture maintains unidirectional data flow and prevents child screens from directly manipulating parent state.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
76-106
app/src/main/java/com/magicword/app/ui/MainScreen.kt
180-233
app/src/main/java/com/magicword/app/ui/MainScreen.kt
253-276
Summary
MainScreen serves as the architectural cornerstone of the MagicWord UI, implementing:
Two-Layer Navigation
: Tab-based primary navigation via
HorizontalPager
and modal overlays for auxiliary screens
Initialization Logic
: Automated update checks and system notice displays on app launch
State Coordination
: Integration with
LibraryViewModel
for reactive state management
Flexible Routing
: Support for programmatic navigation via jump events and callbacks
User Experience
: Smooth animations, progress indicators, and non-dismissible dialogs during critical operations
The design prioritizes separation of concerns—MainScreen handles navigation orchestration while delegating feature logic to specialized screens and ViewModels.
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
MainScreen & Navigation
Purpose and Scope
Architecture Overview
Component Structure
Navigation Structure
Tab-Based Primary Navigation
Screen Sealed Class
Pager Implementation
Initialization System
Update Check Flow
Notice Check Flow
Dialog Systems
Update Dialog
Notice Dialog
Tab Management
Pager Configuration
Tab Switching Mechanisms
1. User Tap on Navigation Bar
2. User Swipe Gesture
3. Programmatic Navigation
Jump Event Handling
Overlay System
Overlay State Machine
Overlay Routing Logic
Overlay Triggers
State Management
Local State
ViewModel Integration
Integration Points
Dependencies
Child Screen Callbacks
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2.2-wordsscreen-vocabulary-management

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
WordsScreen - Vocabulary Management
Relevant source files
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
Purpose and Scope
This document covers the
WordsScreen
component, the primary interface for vocabulary management in the MagicWord Android application. The screen provides dual viewing modes (immersive card-based learning and efficient list-based management), integrated AI-powered word import, search functionality, and comprehensive editing capabilities.
For spaced repetition review functionality, see
StudyScreen - Spaced Repetition Review
. For quiz functionality, see
TestScreen - Quiz Functionality
. For library-level operations (create, delete, switch), see
LibraryManagerScreen - Library Operations
.
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
1-727
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1196
Architecture Overview
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
56-618
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-186
Display Modes
Mode Architecture
The
WordsScreen
supports two distinct viewing modes controlled by the
isListMode
boolean state:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
87-88
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
378-575
Card Mode
Card mode provides an immersive, full-screen learning experience using Jetpack Compose's
VerticalPager
.
Feature
Implementation
Location
Pager State
rememberPagerState(pageCount = { words.size })
WordsScreen.kt
99
Word Display
WordCard
composable with full word details
WordsScreen.kt
507-512
Review Tracking
Increments
reviewCount
on page view
WordsScreen.kt
487-491
Index Persistence
Saves current page to
SharedPreferences
and DB
WordsScreen.kt
472-474
Long Press Action
Switch to List Mode
WordsScreen.kt
503
Side Panel
Optional quick navigation list
WordsScreen.kt
517-571
Key State Management:
Index Restoration Logic:
When switching libraries or returning to Card Mode, the screen restores the last viewed position:
Source:
viewModel.getInitialLastIndex(libraryId)
at
LibraryViewModel.kt
545-553
Restoration:
Occurs in
LaunchedEffect(currentLibraryId, words)
at
WordsScreen.kt
449-470
Exception Handling:
Skips restoration when navigating from global search (
isNavigatingFromSearch
flag)
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
447-575
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
535-553
List Mode
List mode provides efficient bulk management with multi-select, reordering, and batch operations.
Reordering Implementation:
The reordering feature uses the
sh.calvin.reorderable
library:
State Initialization:
WordsScreen.kt
169-175
rememberReorderableLazyListState
with drag callback
Updates
reorderableWords
state immediately for smooth UI
Persists to DB with updated
sortOrder
field
Automatic Sort Switch:
WordsScreen.kt
430-438
When reordering occurs, automatically switches
sortOption
to
CUSTOM
Ensures reordered positions are preserved
Drag Handle:
WordsScreen.kt
413-418
Icon(Icons.Default.DragHandle).draggableHandle()
provides touch target
Selection State:
Type:
Set<Int>
containing word IDs
Checkbox Binding:
WordsScreen.kt
410-412
Batch Actions:
Test (
WordsScreen.kt
239-257
), Delete (
WordsScreen.kt
242-245
)
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
164-446
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
429-438
Search System
Dual Search Modes
The search system provides two distinct functionalities through a single search bar:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
319-350
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
282-380
Local Search (Filter + Scroll)
Triggered on text input, provides instant feedback:
Implementation:
WordsScreen.kt
323-334
Behavior:
Card Mode:
No automatic action (search bar updates for visual feedback)
List Mode:
Auto-scrolls to first matching word
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
323-334
Global AI Search
Triggered by pressing Enter/Search key, performs global lookup and AI import:
Flow Diagram:
AI Prompt Structure:
LibraryViewModel.kt
310-335
The prompt instructs the AI to return a single JSON object with:
word
: Lemma/root form (e.g., "ran" → "run")
phonetic
: IPA pronunciation
senses
: Key-value object with variable sense count
definition_en
: Brief English definition
example
: Sentence with translation
memory_method
: Mnemonic technique
forms
: Word variations (past, plural, etc.)
Navigation Logic:
WordsScreen.kt
124-150
When
globalSearchResult
is populated:
Switch to target library if different
Set
isNavigatingFromSearch = true
(prevents index restoration interference)
Force Card Mode
Find word index in current list
Scroll
pagerState
to that index
Clear result state
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
282-380
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
94-150
Bulk Import System
The bulk import feature extracts vocabulary from long text passages using AI, addressing the common learning scenario of encountering multiple unknown words in articles or books.
Import Architecture
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
599-616
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-924
Import Flow
Step A: Word Extraction
Entry Point:
viewModel.bulkImport(text)
at
LibraryViewModel.kt
698-814
Extraction Logic:
LibraryViewModel.kt
707-756
AI Prompt Construction:
Instructs AI to identify learnable words/phrases
Critical Rule:
Replace spaces in phrases with underscores (e.g., "give up" → "give_up")
Excludes common stop words
Returns JSON array of strings
Response Parsing:
Extracts JSON array from AI response
Handles markdown code blocks if present
Falls back to empty list on parse failure
Validation:
Checks if
wordsList.isEmpty()
Logs error and exits if no words extracted
Example Prompt:
LibraryViewModel.kt
707-719
Identify and extract all unique English words AND phrases...
CRITICAL INSTRUCTION FOR PHRASES:
If the text contains a phrase (e.g., "give up", "look forward to"), you MUST:
1. Extract the phrase itself as a single entry.
2. IMPORTANT: Replace spaces in phrases with UNDERSCORES...
Step B: Chunked Parallel Processing
Processing Strategy:
LibraryViewModel.kt
758-790
Parameter
Value
Rationale
Chunk Size
3 words
Prevents API timeout on large batches
Concurrency
3 parallel chunks
Balances speed vs. rate limits
Max Retries
3 per chunk
Handles transient failures
Queue Type
ArrayDeque<Pair<List<String>, Int>>
Efficient FIFO with retry count
Parallel Execution Pattern:
Chunk Processing:
LibraryViewModel.kt
817-865
For each chunk:
Call
fetchWordDefinitionsFromAi(chunk)
at
LibraryViewModel.kt
867-917
Parse
List<StandardizedWord>
from JSON response
Restore spaces in phrase names:
word.replace("_", " ")
Insert each word via
wordDao.insertWord()
Add to
importedWordsSet
(thread-safe synchronized set)
On exception: re-queue with incremented retry count
AI Definition Prompt:
LibraryViewModel.kt
872-898
Key features:
Processes multiple words in single request (batch efficiency)
Includes optional
userPersona
context from
AppConfig.userPersona
Requests variable sense count (not forced to 10)
Handles underscored phrases (AI returns "give_up" or "give up")
Step D: Validation (Disabled)
Location:
LibraryViewModel.kt
920-924
Originally performed AI sanity check on imported words, but now skipped per user configuration:
Rationale:
Prevents duplicate words from over-eager validation
Reduces total API calls
Simplifies flow and avoids potential recursion
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-924
Import UI Components
Bulk Import Sheet:
WordsScreen.kt
672-726
State Observables:
StateFlow
Purpose
Source
importLogs
Real-time progress messages
LibraryViewModel.kt
462-463
isImporting
Disables button during processing
LibraryViewModel.kt
465-466
Keyboard Handling:
Uses
.imePadding()
and
.navigationBarsPadding()
at
WordsScreen.kt
680-681
to ensure content remains visible when keyboard appears.
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
672-726
Word Editing
Edit Dialog Architecture
Trigger Locations:
List Mode - Single Tap:
WordsScreen.kt
435-437
Card Mode - Edit Button:
WordsScreen.kt
509
Dialog Rendering:
WordsScreen.kt
587-597
Update Operation:
LibraryViewModel.kt
563-567
Persists changes via Room:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
435-437
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
587-597
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
563-567
Sorting System
Sort Options
The
LibraryViewModel
defines six sort options as an enum:
Enum Definition:
LibraryViewModel.kt
245-253
Sort Persistence
State Flow:
LibraryViewModel.kt
255-262
Persistence Method:
LibraryViewModel.kt
264-267
Sort Implementation
The
allWords
Flow combines
currentLibraryId
and
sortOption
to produce sorted results:
Flow Construction:
LibraryViewModel.kt
404-418
Sort Logic:
LibraryViewModel.kt
408-417
Auto-Switch on Reorder:
LibraryViewModel.kt
430-438
When user manually reorders words, the sort automatically switches to
CUSTOM
to preserve the new order.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
245-267
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
404-438
Side List Panel
The side list provides quick navigation in Card Mode without switching to full List Mode.
Panel Architecture
Toggle Button:
WordsScreen.kt
352-361
Only visible in Card Mode:
Auto-Centering Logic:
WordsScreen.kt
526-541
Uses viewport height calculations to center the selected item:
Visual Styling:
WordsScreen.kt
550-569
State
Background
Text Color
Font Weight
Selected
Color(0xFF2196F3)
(Blue)
White
Bold
Unselected
Transparent
onSurface
Normal
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
352-361
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
517-571
Text-to-Speech Integration
TTS Lifecycle
Initialization:
LibraryViewModel.kt
79-98
Speech Rate:
Set to
0.9f
(10% slower than normal) for improved pronunciation clarity.
Speak Function:
LibraryViewModel.kt
100-104
Cleanup:
LibraryViewModel.kt
106-110
Properly releases TTS resources in
onCleared()
:
UI Integration Points:
Card Mode:
WordsScreen.kt
510
Edit Dialog:
WordsScreen.kt
595
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
74-110
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
70-73
Navigation Integration
Jump Navigation System
The
WordsScreen
supports programmatic navigation from other screens (e.g.,
WordListScreen
).
ViewModel Implementation:
LibraryViewModel.kt
972-980
WordsScreen Handling:
WordsScreen.kt
153-161
Pre-Navigation Setup:
WordsScreen.kt
117-122
Forces Card Mode when jump is pending:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
963-980
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
113-161
Library Switching
Swipe Gesture:
WordsScreen.kt
206-213
Horizontal swipe from left edge opens Library Manager:
Title Bar Click:
WordsScreen.kt
220-233
Tapping the library name also opens the manager:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
206-233
Batch Operations
Test Selected Words
UI Flow:
User selects words via checkboxes in List Mode
Taps "Test" icon button at
WordsScreen.kt
239-241
Dialog appears to choose test type:
WordsScreen.kt
249-257
On confirmation:
Filters selected words:
words.filter { selectedWords.contains(it.id) }
Calls
viewModel.setTestCandidates(selectedList)
Calls
viewModel.setTestType(type)
Navigates to
TestScreen
via
onJumpToTest()
ViewModel State:
LibraryViewModel.kt
480-486
The
TestScreen
reads this state to populate quiz questions. For details, see
TestScreen - Quiz Functionality
.
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
239-257
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
480-486
Delete Selected Words
Implementation:
WordsScreen.kt
242-245
ViewModel Method:
LibraryViewModel.kt
555-561
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
242-245
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
555-561
Select All / Deselect All
Toggle Logic:
WordsScreen.kt
288-291
Behavior:
If all words selected: clears selection
Otherwise: selects all words in current view
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
288-291
State Synchronization
Reactive Data Flow
Key Characteristics:
Unidirectional Data Flow:
UI observes StateFlows, user actions trigger ViewModel methods
Dual Persistence:
Critical state (library ID, sort option) persisted to both Room DB and SharedPreferences
Derived Flows:
allWords
is a computed flow combining multiple sources
Reactive UI:
Compose automatically recomposes when StateFlows emit new values
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-418
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
75-84
Configuration Change Handling
State Preservation
Preserved Automatically:
All ViewModel state (due to ViewModel lifecycle)
Database contents
SharedPreferences values
Recreated on Rotation:
isListMode
- always defaults to
false
(Card Mode)
editingWord
- dialog closes
showImportSheet
- sheet closes
selectedWords
- selection cleared
searchQuery
- search text cleared
Restoration Logic:
The pager position is restored via
LaunchedEffect
at
WordsScreen.kt
449-470
:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
449-470
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
WordsScreen - Vocabulary Management
Purpose and Scope
Architecture Overview
Display Modes
Mode Architecture
Card Mode
List Mode
Search System
Dual Search Modes
Local Search (Filter + Scroll)
Global AI Search
Bulk Import System
Import Architecture
Import Flow
Step A: Word Extraction
Step B: Chunked Parallel Processing
Step D: Validation (Disabled)
Import UI Components
Word Editing
Edit Dialog Architecture
Sorting System
Sort Options
Sort Persistence
Sort Implementation
Side List Panel
Panel Architecture
Text-to-Speech Integration
TTS Lifecycle
Navigation Integration
Jump Navigation System
Library Switching
Batch Operations
Test Selected Words
Delete Selected Words
Select All / Deselect All
State Synchronization
Reactive Data Flow
Configuration Change Handling
State Preservation

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2.3-studyscreen-spaced-repetition-review

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
StudyScreen - Spaced Repetition Review
Relevant source files
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
app/src/main/java/com/magicword/app/ui/WordCard.kt
Purpose and Scope
This document describes the
StudyScreen
component and its integration with the
SM-2 (SuperMemo-2) spaced repetition algorithm
. This system is responsible for scheduling and presenting vocabulary reviews to optimize long-term retention. The StudyScreen provides an interactive flashcard interface where users review words that are due for review based on their performance history.
Key Responsibilities:
Display due words in a flashcard format with question/answer interaction
Collect user quality ratings (0-5) for each review
Apply SM-2 algorithm to calculate next review intervals
Support multi-library review sessions
Persist review statistics (repetitions, intervals, easiness factors)
Provide text-to-speech pronunciation support
For information about the testing system (multiple choice/spelling quizzes), see
TestScreen - Quiz Functionality
. For details on the SM-2 algorithm mathematics, see
Spaced Repetition System (SM-2)
. For vocabulary management outside of review, see
WordsScreen - Vocabulary Management
.
System Architecture
The StudyScreen operates as part of the Android MVVM architecture, coordinating between the UI layer and the LibraryViewModel for data operations.
Architecture Notes:
StudyScreen is a stateless Composable that observes StateFlows from LibraryViewModel
dueWords
is a derived Flow combining
currentLibraryId
and
studyLibraryIds
(see
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
)
Review results immediately trigger database updates through
processReview()
Library selection persists to SharedPreferences for session continuity
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
1-468
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-165
SM-2 Spaced Repetition Algorithm
The core learning algorithm is implemented in
LibraryViewModel.processReview()
. This function calculates the next review interval based on user performance ratings.
Algorithm Implementation
Implementation Details
The algorithm is implemented in
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
:
Parameter
Type
Purpose
quality
Int (0-5)
User-reported recall difficulty (0=Blackout, 5=Perfect)
repetitions
Int
Number of consecutive successful reviews
interval
Int
Days until next review
easinessFactor
Float
Difficulty multiplier (≥1.3)
nextReviewTime
Long
Timestamp (milliseconds) for next review
Quality Ratings:
0 (忘记/Forgot)
: Complete failure → Reset repetitions and interval
3 (困难/Hard)
: Difficult but correct → Normal progression
4 (良好/Good)
: Moderate ease → Normal progression with slight EF increase
5 (简单/Easy)
: Perfect recall → Normal progression with maximum EF increase
Key Formulas:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
Study Session Flow
The study session lifecycle manages the user's progression through due words, from initialization to completion.
Initialization Logic
The StudyScreen employs auto-start behavior to immediately present flashcards when due words are available:
This ensures that users see vocabulary immediately upon entering the screen, rather than requiring a manual "Start Review" button press. The
hasAutoStarted
flag prevents re-triggering after the user manually exits review mode.
Session State Variables
Variable
Type
Purpose
currentWordIndex
Int
Index in the
dueWords
list (0-based)
isReviewing
Boolean
Whether flashcard UI is active
showAnswer
Boolean
Whether answer is revealed on current card
hasAutoStarted
Boolean
Prevents re-auto-start after manual exit
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
40-468
Library Selection & Multi-Library Review
Users can select multiple libraries to review simultaneously. The system merges due words from all selected libraries into a single review queue.
Library Selection UI
Data Flow for Multi-Library Reviews
The
dueWords
Flow combines library selection state with database queries:
Behavior:
If no libraries are explicitly selected (
studyLibraryIds.isEmpty()
), defaults to
currentLibraryId
getDueWordsForLibraries()
queries words where
nextReviewTime <= NOW
across all selected libraries
Selection persists to SharedPreferences using the key
"study_library_ids"
(see
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
217-219
)
Library Validation on Init
The ViewModel validates selected libraries against the database on startup to handle deleted libraries:
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
156-441
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
173-242
Flashcard UI Components
The flashcard interface provides a question-answer interaction pattern optimized for spaced repetition learning.
Card Structure
Interaction States
The flashcard has three distinct interaction modes:
Mode
UI State
User Action
Next State
Question
Shows word + phonetic only
Tap card
Answer
Answer
Shows full definition + examples
Tap rating button
Next Card
Loading
Empty card shown before first word loads
-
Question
Rating Button Component
The rating buttons appear below the flashcard when the answer is revealed:
Button Mapping:
忘记 (Forgot)
: Quality 0, Red (0xFFE57373)
困难 (Hard)
: Quality 3, Orange (0xFFFFB74D)
良好 (Good)
: Quality 4, Green (0xFF81C784)
简单 (Easy)
: Quality 5, Blue (0xFF64B5F6)
Progress Indicator
A
LinearProgressIndicator
displays review progress:
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
249-358
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
446-467
State Management
StudyScreen follows a reactive state management pattern where all data flows through StateFlows from LibraryViewModel.
State Flow Diagram
Key StateFlows
StateFlow
Type
Persistence
Purpose
dueWords
Flow<List<Word>>
Database
Reactive list of words due for review
studyLibraryIds
StateFlow<Set<Int>>
SharedPreferences
Selected libraries for study session
isTtsReady
StateFlow<Boolean>
None
Whether TTS engine is initialized
currentLibraryId
StateFlow<Int>
SharedPreferences
Default/fallback library
Local UI State
StudyScreen maintains several
remember
-scoped state variables that do not persist across configuration changes:
These states reset when the screen is recomposed (e.g., after rotation), which is acceptable because:
dueWords
Flow automatically reloads the word list
Review progress is saved to the database immediately upon each rating
Users expect to restart from the beginning of a session after orientation changes
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-242
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
40-150
Text-to-Speech Integration
The StudyScreen integrates Android's TextToSpeech API to provide pronunciation support for vocabulary words.
TTS Initialization
Implementation Details
The TTS engine is initialized once per ViewModel lifecycle:
Configuration:
Language
:
Locale.US
(American English)
Speech Rate
: 0.9f (10% slower than default for improved clarity)
Queue Mode
:
QUEUE_FLUSH
(interrupts previous speech)
Speaking Words
The
speak()
function is called when users tap the speaker icon on the flashcard:
Usage in UI:
Cleanup
The TTS engine is properly released when the ViewModel is cleared:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
74-110
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
49-287
Review Data Flow
The complete data flow from user interaction to database persistence is outlined below.
Updated Word Fields
When
processReview()
completes, the following fields are updated in the database:
Field
Update Logic
repetitions
Reset to 0 if quality < 3, else increment
interval
Reset to 1 if quality < 3, else calculated by SM-2
easinessFactor
Updated by formula if quality >= 3, otherwise unchanged
nextReviewTime
System.currentTimeMillis() + interval * 24 * 60 * 60 * 1000
lastReviewTime
System.currentTimeMillis()
reviewCount
Incremented by 1
correctCount
Incremented if quality >= 3
incorrectCount
Incremented if quality < 3
ProcessResult Helper Function
The
processResult()
helper coordinates the review action:
Callback Responsibilities:
onNext
: Advances
currentWordIndex
to move to the next card
resetCardState
: Resets
showAnswer
to hide the answer on the new card
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
336-467
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
Dashboard and Session Completion
When no words are due for review, or when the user exits review mode, the dashboard provides session status and actions.
Dashboard States
Paused State UI
When words are available but
isReviewing=false
:
Finished State UI
When
dueWords.isEmpty()
:
Note:
The "巩固复习" (Consolidate Review) button is a placeholder for a future feature that would allow users to review words that are not yet due, providing additional practice opportunities.
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
176-244
Library Renaming in Study Context
Users can rename libraries directly from the Study screen's library selection dialog without navigating to the library management screen.
Rename Interaction Flow
Implementation
The rename functionality is implemented inline within the library selection dialog:
The
renameLibrary()
function in LibraryViewModel uses Room's
@Insert(onConflict = REPLACE)
strategy:
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
361-441
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
221-233
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
StudyScreen - Spaced Repetition Review
Purpose and Scope
System Architecture
SM-2 Spaced Repetition Algorithm
Algorithm Implementation
Implementation Details
Study Session Flow
Initialization Logic
Session State Variables
Library Selection & Multi-Library Review
Library Selection UI
Data Flow for Multi-Library Reviews
Library Validation on Init
Flashcard UI Components
Card Structure
Interaction States
Rating Button Component
Progress Indicator
State Management
State Flow Diagram
Key StateFlows
Local UI State
Text-to-Speech Integration
TTS Initialization
Implementation Details
Speaking Words
Cleanup
Review Data Flow
Updated Word Fields
ProcessResult Helper Function
Dashboard and Session Completion
Dashboard States
Paused State UI
Finished State UI
Library Renaming in Study Context
Rename Interaction Flow
Implementation

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2.4-testscreen-quiz-functionality

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
TestScreen - Quiz Functionality
Relevant source files
app/src/main/java/com/magicword/app/data/TestSession.kt
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/TestScreen.kt
error.txt
Purpose and Scope
This document describes the quiz system implemented in the TestScreen component, which provides two testing modes (multiple-choice and spelling) for vocabulary assessment. The system includes session persistence, test history tracking, and automatic word statistics updates. This page covers the UI implementation, state management, and data flow for the testing feature.
For information about the SM-2 spaced repetition algorithm used in study mode, see
2.3.2
. For general LibraryViewModel state management, see
2.1.1
.
Architecture Overview
The test system is built around three main UI components (
TestScreen
,
QuizChoiceMode
,
QuizSpellMode
) that interact with the
LibraryViewModel
for state management and persistence. The system supports interrupted test resumption through database-backed session storage and maintains comprehensive test history.
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
1-725
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
468-527
Component Breakdown
TestScreen - Main Container
The
TestScreen
composable serves as the orchestration layer for the quiz functionality, managing tab navigation and coordinating between test modes and history views.
Responsibility
Implementation
Tab Management
Two tabs: "选择题" (Choice) and "拼写" (Spell)
Test Source Display
Shows "正在测试选中单词" when
testCandidates
is active
History Access
IconButton with
Icons.Filled.History
to open full-screen history
Session Restoration
LaunchedEffect synchronizes saved session with UI state
Auto-Save
LaunchedEffect monitors
choiceQuizState
changes and persists via
saveTestSession
Key State Variables:
selectedTab: Int
- Currently active tab (0=Choice, 1=Spell)
showHistoryScreen: Boolean
- Controls full-screen history overlay
choiceQuizState: MutableState<QuizState>
- Persistent quiz state using custom Saver
testCandidates: List<Word>?
- When non-null, tests only selected words instead of entire library
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
76-231
QuizState - Parcelable State Holder
The
QuizState
data class encapsulates all quiz progress information and implements
Parcelable
for configuration-change survival.
Design Rationale:
Stores indices instead of full
Word
objects to maintain
Parcelable
compliance. The indices reference positions in the
words
list passed to
QuizChoiceMode
.
Custom Saver:
Uses
Saver<MutableState<QuizState>, QuizState>
pattern to integrate with
rememberSaveable
for automatic state persistence across process death.
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
359-372
Multiple Choice Mode - QuizChoiceMode
Word Filtering Logic
Before starting a quiz, words are filtered based on recent review activity to prevent excessive daily testing:
Implementation:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
383-407
The 24-hour filter prevents users from repeatedly testing the same words, implementing a cooldown period. If all words are filtered out, the system falls back to the full word list, effectively allowing a "restart" for users who want to continue practicing.
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
383-407
Quiz Flow and Option Generation
Each question displays the English word and presents four options (the correct Chinese definition plus three distractors):
Option Generation Algorithm:
Filter
finalWords
to exclude current word:
finalWords.filter { it.id != currentWord.id }
Shuffle and take 3:
.shuffled().take(3)
Fallback to global
words
if insufficient distractors in filtered list
Combine with correct answer and shuffle again:
(wrongOptions + currentWord).shuffled()
Immediate Feedback System:
selectedOptionId: Int?
- Tracks user selection
isAnswered: Boolean
- Prevents multiple clicks
Color coding: Correct option → Green, Selected wrong → Red, Others → Default
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
457-601
Auto-Advance Mechanism
After the user selects an answer, the system provides 1 second of visual feedback before automatically advancing:
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
576-598
Test Completion and Statistics Update
Upon quiz completion, the system triggers three critical operations:
Save Test History:
Creates
TestHistory
record with serialized
TestResultItem
list
Clear Session:
Removes
TestSession
from database to reset for next test
Update Word Stats:
Iterates through results and calls
updateWordStats(wordId, isCorrect)
for each word
TestResultItem Structure:
wordId: Int
- Foreign key to word table
word: String
- Word text for display
isCorrect: Boolean
- Answer correctness
userAnswer: String?
- User's selected option (for spell mode or wrong answers)
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
210-226
Spelling Mode - QuizSpellMode
The spelling mode presents the Chinese definition and requires users to type the correct English word. This mode tests active recall rather than passive recognition.
Feature
Implementation
Input Method
OutlinedTextField
with
ImeAction.Done
Validation
Case-insensitive comparison:
input.trim().equals(currentWord.word, ignoreCase = true)
Progress Tracking
Uses
rememberSaveable
for
currentIndex
,
score
,
isFinished
,
input
Word Order
Separate shuffled indices:
spellIndices = rememberSaveable { mutableStateOf(words.indices.toList().shuffled()) }
History
Currently does not persist to database (potential enhancement)
Key Limitation:
Unlike choice mode, spell mode does not save detailed test results to
TestHistory
. This appears to be an area for future enhancement.
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
604-724
Session Persistence System
Database Schema
The
TestSession
entity stores active test state to enable resumption after app termination:
Sources:
app/src/main/java/com/magicword/app/data/TestSession.kt
1-15
Persistence Flow
Restoration Logic:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
123-143
The restoration checks if
savedSession.libraryId
matches the current test source to prevent loading stale data from a different library.
Auto-Save Logic:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
146-161
Every modification to
choiceQuizState.value
triggers
LaunchedEffect
which serializes the state and calls
viewModel.saveTestSession(session)
.
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
120-164
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
489-511
Test History System
TestHistory Entity
Historical test results are stored with full question details serialized as JSON:
Field
Type
Purpose
id
Int (Auto)
Primary key
timestamp
Long
Test completion time (milliseconds)
totalQuestions
Int
Number of questions attempted
correctCount
Int
Number of correct answers
testType
String
"CHOICE" or "SPELL"
durationSeconds
Int
Test duration (currently always 0)
questionsJson
String
Serialized
List<TestResultItem>
TestResultItem Structure:
Sources:
app/src/main/java/com/magicword/app/data/TestHistory.kt
(inferred from usage),
app/src/main/java/com/magicword/app/ui/TestScreen.kt
33-34
History UI Components
TestHistoryScreen:
Displays chronological list of all test sessions.
Data Source:
viewModel.testHistory
Flow
List Items:
Shows date, test type, score, and percentage
Empty State:
"暂无测试记录" when no history exists
Interaction:
Clicking item sets
selectedHistoryItem
to show detail view
TestHistoryDetailScreen:
Shows individual question results for a completed test.
Data Parse:
Deserializes
history.questionsJson
into
List<TestResultItem>
using Gson
Summary Card:
Displays total questions, correct count, incorrect count with color coding
Detail List:
Each word shown with check/clear icon indicating correctness
Wrong Answer Display:
Shows
userAnswer
field for incorrect responses (red text)
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
234-280
(TestHistoryScreen),
app/src/main/java/com/magicword/app/ui/TestScreen.kt
283-355
(TestHistoryDetailScreen)
ViewModel Integration
Test-Related State Flows
The
LibraryViewModel
exposes multiple StateFlows for test coordination:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
468-520
Test Candidate Selection
The
testCandidates
mechanism allows users to test a specific subset of words (e.g., selected from WordsScreen):
UI Behavior:
When
testCandidates
is non-null, TestScreen shows "正在测试选中单词 (X个)"
Close button (
Icons.Filled.Close
) calls
setTestCandidates(null)
to exit selection mode
Quiz components use
testCandidates ?: allWords
to determine word source
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
481-486
app/src/main/java/com/magicword/app/ui/TestScreen.kt
89-92
Word Statistics Update
When a test completes, each word's statistics are updated to reflect test performance:
The
WordDao.updateWordStats
function increments either
correctCount
or
incorrectCount
and updates
lastReviewTime
. This data can be used for analytics or future adaptive testing features.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
523-527
State Management Architecture
Key Patterns:
Local UI State:
rememberSaveable
handles configuration changes (rotation, dark mode toggle)
Session State:
Database-backed for process death survival (app killed by system)
History State:
Direct Room Flow eliminates need for intermediate StateFlow
Transient State:
showHistoryScreen
uses
remember
since it's ephemeral navigation state
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
76-231
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
468-520
Test Type Synchronization
The system maintains synchronization between
testType
StateFlow and the UI's
selectedTab
:
This ensures that if another component (e.g., MainScreen navigation) sets the test type, the TestScreen UI automatically switches to the correct tab.
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
98-108
Summary
The TestScreen quiz system implements a robust testing framework with the following characteristics:
Feature
Implementation
Test Modes
Multiple-choice (immediate feedback) and spelling (input-based)
Session Persistence
Database-backed via
test_session
table, survives process death
History Tracking
Comprehensive test results stored as JSON with per-question details
Word Statistics
Automatic
correctCount
/
incorrectCount
updates post-test
Smart Filtering
24-hour cooldown to prevent excessive daily testing
Candidate Selection
Support for testing word subsets via
testCandidates
State Recovery
Multi-level persistence (rememberSaveable + Room) ensures no data loss
Sources:
app/src/main/java/com/magicword/app/ui/TestScreen.kt
1-725
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
468-527
app/src/main/java/com/magicword/app/data/TestSession.kt
1-15
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
TestScreen - Quiz Functionality
Purpose and Scope
Architecture Overview
Component Breakdown
TestScreen - Main Container
QuizState - Parcelable State Holder
Multiple Choice Mode - QuizChoiceMode
Word Filtering Logic
Quiz Flow and Option Generation
Auto-Advance Mechanism
Test Completion and Statistics Update
Spelling Mode - QuizSpellMode
Session Persistence System
Database Schema
Persistence Flow
Test History System
TestHistory Entity
History UI Components
ViewModel Integration
Test-Related State Flows
Test Candidate Selection
Word Statistics Update
State Management Architecture
Test Type Synchronization
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2.5-librarymanagerscreen-library-operations

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
LibraryManagerScreen - Library Operations
Relevant source files
app/src/main/java/com/magicword/app/data/ExportModels.kt
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
Purpose and Scope
This document covers the
LibraryManagerScreen
component, which provides a dual-tab interface for managing local vocabulary libraries and accessing the online library catalog. The screen enables users to:
Local Tab
: Create, delete, switch between libraries, and upload library packages to share with the community
Online Tab
: Browse, search, filter by tags, and download libraries from the GitHub-backed catalog
For information about library data persistence and database operations, see
Data Layer & Persistence
. For details on the Cloudflare Worker API gateway that handles online library operations, see
Cloudflare Worker - API Gateway
. For the GitHub-based storage structure, see
GitHub Data Warehouse
.
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
1-471
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
63-1186
Screen Architecture
The
LibraryManagerScreen
implements a
TabRow-based dual interface
with two primary modes:
Tab
Purpose
Key Operations
本地词库
(Local)
Manage locally stored libraries
Create, delete, switch, select for upload
在线词库
(Online)
Browse community-shared libraries
Search, filter by tags, download, import
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
21-59
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
68-991
Local Library Management
UI Components and Layout
The
LocalLibraryTab
displays a scrollable list of libraries with selection checkboxes, status indicators, and action buttons:
Key State Management
:
selectedLibraries
: Local component state (
mutableStateOf(setOf<Int>())
) tracking which libraries are selected for upload
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
65
currentLibraryId
: ViewModel state indicating the active library
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
167-168
importLogs
: Shared state for displaying operation feedback
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
462-463
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
62-187
CRUD Operations
Create Library
The
AddLibraryDialog
(not shown in provided files but referenced) calls
viewModel.addLibrary(name)
:
The new library is inserted into Room database with auto-generated ID.
Delete Library
Protection
: The default library (ID = 1) cannot be deleted
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
178-182
Switch Library
Switching persists to SharedPreferences and triggers reactive UI updates via StateFlow.
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
398-460
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
98-99
Export and Upload
Export Flow
The export system supports
multi-library packaging
using
ExportPackage
:
Data Model
:
Upload Implementation
:
The
uploadLibraryPackage
function
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1116-1158
performs:
Generate JSON
: Call
getLibraryJson(libraryIds)
to serialize selected libraries
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1122
Base64 Encode
: Prevent JSON escaping issues during HTTP transport
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1124
Build Request Body
: Create JSON object with metadata (name, description, tags) and content
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1127-1136
POST to Worker
: Send to
https://mag.upxuu.com/library/upload
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1138-1141
Handle Response
: Update logs and refresh online list on success
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1144-1151
UI Trigger
: The
UploadLibraryDialog
collects metadata and invokes the upload
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
141-151
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
582-1158
app/src/main/java/com/magicword/app/data/ExportModels.kt
1-19
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
141-471
Online Library Catalog
Data Model and Index Structure
The online library system uses a
paginated index architecture
managed by GitHub Actions:
OnlineLibrary Structure
app/src/main/java/com/magicword/app/data/ExportModels.kt
24-32
:
Field
Type
Purpose
id
String
Unique identifier (timestamp-based)
name
String
Display name
description
String
Detailed description
timestamp
Long
Creation/upload time (millis)
author
String
Creator username
tags
List<String>?
Category tags (nullable)
downloadUrl
String
URL to library.json file
Sources
:
app/src/main/java/com/magicword/app/data/ExportModels.kt
24-32
Browsing and Pagination
The online tab implements
progressive pagination
with automatic load-more triggering:
Key Implementation Details
:
Initial Load
: Fetches
num.json
to determine
totalPages
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1040-1052
Batch Processing
: Attempts to fetch
BATCH_SIZE = 10
items per user action
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1061
Multi-Page Fetch
: If filtering reduces results, automatically fetches next pages (max 5 attempts)
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1068-1098
Load More Trigger
: LazyColumn monitors scroll position and triggers when
index >= size - 3
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
327-331
Append Strategy
: New items are appended to existing list, not replaced
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1100
State Management
:
currentPage
: Internal mutable variable tracking pagination state
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
983
isLoadingMore
: Prevents concurrent fetches
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
985
_onlineLibraries
: MutableStateFlow exposed as StateFlow
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
68-69
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
983-1114
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
318-342
Search and Tag Filtering
Tag System
Tags are fetched from
tags.json
which contains aggregated metadata:
UI Presentation
: Tags are displayed in a collapsible drawer with
FilterChip
components showing tag name and count
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
210-248
Client-Side Filtering
The search and filter logic is
entirely client-side
after fetching index pages:
Search Trigger
:
Manual: IconButton in OutlinedTextField trailing icon
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
273-277
Automatic: Called by
searchOnlineLibraries(query, tag)
which resets pagination
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1016-1020
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
993-1088
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
210-293
Download and Import
Download Flow
Import Logic
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
644-696
:
Try New Format
: Attempt to parse as
ExportPackage
with multiple libraries
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
651-672
Fallback to Legacy
: If parsing fails, try
List<Word>
format
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
678-686
Create New Libraries
: Each library in the package gets a fresh ID to avoid conflicts
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
658-662
Word Assignment
: All words are re-assigned to the new library ID with
word.copy(id = 0, libraryId = newLibId)
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
665-666
Network Call
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1160-1185
:
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
644-1185
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
320-410
State Flow Summary
The LibraryManagerScreen coordinates multiple reactive state streams from
LibraryViewModel
:
StateFlow
Type
Purpose
Update Trigger
allLibraries
Flow<List<Library>>
Local libraries from Room
Database updates via DAO
currentLibraryId
StateFlow<Int>
Active library indicator
switchLibrary()
onlineLibraries
StateFlow<List<OnlineLibrary>>
Fetched online catalog
fetchOnlineLibraries()
,
loadMoreOnlineLibraries()
onlineTags
StateFlow<List<Pair<String, Int>>>
Available filter tags
fetchOnlineTags()
isNetworkLoading
StateFlow<Boolean>
Network operation status
OkHttp request lifecycle
importLogs
StateFlow<List<String>>
Operation feedback messages
Various operations (upload, download, import)
Reactive UI Pattern
:
All UI state changes are driven by these StateFlow emissions, ensuring unidirectional data flow.
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
68-991
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
63-195
Error Handling and Loading States
The screen provides comprehensive feedback through multiple UI elements:
Progress Indicators
:
LinearProgressIndicator
: Shown during initial online fetch
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
294-296
CircularProgressIndicator
: Bottom indicator for load-more operations
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
336-340
Status Messages
:
Card
displaying last log entry from
importLogs
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
76-306
Logs include: "正在上传...", "✅ 上传成功", "❌ 下载失败", etc.
Empty States
:
Online tab shows retry button when no libraries loaded
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
308-316
Exception Logging
:
Network errors logged via
LogUtil.logError()
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1011-1104
User-facing errors added to
_importLogs
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1150-1180
Sources
:
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
76-340
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1011-1180
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
LibraryManagerScreen - Library Operations
Purpose and Scope
Screen Architecture
Local Library Management
UI Components and Layout
CRUD Operations
Create Library
Delete Library
Switch Library
Export and Upload
Export Flow
Online Library Catalog
Data Model and Index Structure
Browsing and Pagination
Search and Tag Filtering
Tag System
Client-Side Filtering
Download and Import
Download Flow
State Flow Summary
Error Handling and Loading States

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.2.6-settingsscreen-and-configuration

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
SettingsScreen & Configuration
Relevant source files
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
app/src/main/java/com/magicword/app/utils/AppConfig.kt
Purpose and Scope
This document covers the
SettingsScreen
UI component and the
AppConfig
singleton that together manage application-wide configuration in MagicWord. The settings system provides user interfaces for configuring AI integration parameters, personalization options, system preferences, and the unique
Key-Kit
authentication mechanism that simplifies multi-parameter API configuration.
For information about the update checking and download functionality exposed through this screen, see
Update System
. For details on log generation and storage mechanisms, see the logging utilities referenced in this document.
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
1-337
app/src/main/java/com/magicword/app/utils/AppConfig.kt
1-61
Architecture Overview
The configuration system follows a
three-tier persistence model
with immediate UI reactivity:
Diagram: Configuration Data Flow Architecture
The system uses
DisposableEffect
to trigger configuration persistence when the user navigates away from the settings screen, ensuring all changes are automatically saved without explicit "Save" buttons.
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
87-93
app/src/main/java/com/magicword/app/utils/AppConfig.kt
28-55
AppConfig Singleton
AppConfig
is the
single source of truth
for application-wide configuration, implemented as a Kotlin
object
(singleton):
Diagram: AppConfig Class Structure
Configuration Properties
Property
Type
Default
Description
apiKey
String
""
AI service API authentication key
modelName
String
"Qwen/Qwen2.5-7B-Instruct"
AI model identifier
serverUrl
String
""
AI service base URL (set via Key-Kit)
userPersona
String
""
User context for AI personalization
saveLocationId
Int
-1
Target library for new words (-1 = current)
Initialization
The
init(Context)
method
app/src/main/java/com/magicword/app/utils/AppConfig.kt
28-35
reads all configuration values from SharedPreferences with key prefix
"app_config"
. This must be called during application startup before any AI operations.
Persistence
Configuration changes are written via
saveConfig()
app/src/main/java/com/magicword/app/utils/AppConfig.kt
41-55
which:
Updates in-memory properties
Commits values to SharedPreferences atomically
Optionally updates only specified parameters (null parameters are unchanged)
Sources:
app/src/main/java/com/magicword/app/utils/AppConfig.kt
1-61
Key-Kit Verification System
The
Key-Kit
system abstracts the complexity of multi-parameter API configuration into a single verification key, reducing user friction during setup:
Diagram: Key-Kit Verification Flow
Implementation Details
The verification logic
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
119-146
uses:
Dynamic Retrofit Client
: Builds a temporary
ServerApi
instance targeting
https://mag.upxuu.com/
Verification Request
: Sends
VerifyKitRequest(kitKey)
to the
/verify-kit
endpoint
Batch Update
: If
valid == true
, updates:
apiKey
→ AppConfig
modelName
→ AppConfig
baseUrl
→ SharedPreferences (
"ai_base_url"
key)
Reload Trigger
: Calls
AppConfig.reload(context)
to refresh the base URL for future network calls
UI State Management
The button is
enabled
only when
!isVerifyingKit && kitKey.isNotBlank()
, preventing duplicate submissions.
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
53-146
Configuration Categories
AI Configuration Section
UI Elements:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
106-168
Key-Kit Input
: Single-line
OutlinedTextField
for batch credential update
API Key Field
: Read-only display (manual override possible) showing current
AppConfig.apiKey
Model Name Field
: Editable text field for
AppConfig.modelName
All fields use local state variables initialized from
AppConfig
properties:
Personalization Section
UI Elements:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
173-200
Setting
Type
Description
User Persona
Multi-line TextField
Context string passed to AI for personalized examples/mnemonics
Save Location
DropdownMenu
Target library ID for new word imports (
-1
= follow current library)
Save Location Logic
: Displays a
Button
that opens a
DropdownMenu
populated from
LibraryViewModel.allLibraries
flow. Special entry "跟随当前" sets
saveLocationId = -1
.
System Preferences Section
UI Elements:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
205-224
Preference
Type
SharedPreferences Key
Effect
Enable Logging
Switch
"enable_log"
Calls
LogUtil.setLogEnabled()
on toggle
Auto Update
Switch
"auto_update"
Controls automatic update checks in MainScreen
Both settings persist to the
"app_settings"
SharedPreferences file (separate from
AppConfig
).
Links & About Section
UI Elements:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
228-260
Clickable
ListItem
components that launch external URLs or navigate to other screens:
Documentation:
https://magicword.upxuu.com/
GitHub Repository:
https://github.com/lijiaxu2021/MagicWord
Developer Blog:
https://upxuu.com
Log List Screen: Navigates via
onNavigateToLogs()
callback
About Screen: Navigates via
onNavigateToAbout()
callback
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
40-264
Persistence Mechanism
Two-Tier SharedPreferences Architecture
Diagram: Dual SharedPreferences Persistence
Save Trigger
The
saveAllConfig()
function
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
87-91
is invoked by:
This ensures
automatic persistence
when:
User navigates back
Screen is disposed due to configuration change
App is backgrounded (triggers disposal)
Data Flow Summary
Read
:
AppConfig.init(context)
loads all values from
"app_config"
SharedPreferences at app startup
Edit
: User modifies settings via UI, updating local
mutableStateOf
variables
Write
:
onDispose
triggers
saveAllConfig()
, which:
Calls
AppConfig.saveConfig()
→ writes AI/personalization settings
Calls
prefs.edit()
directly → writes system preferences
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
87-93
app/src/main/java/com/magicword/app/utils/AppConfig.kt
41-55
Update Management Integration
The Settings Screen provides UI for update checking via
UpdateManager
:
Diagram: Update Check Flow from Settings
UI State Variables
The
ListItem
showing current version
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
220-224
displays:
supportingContent
: "Checking..." during check, or "v{VERSION_NAME}" when idle
headlineContent
: "检查更新"
Clickable to trigger
checkUpdate()
function
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
58-79
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
220-224
Log Management UI
LogListScreen Component
A separate full-screen component
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
294-319
that:
Fetches Log Files
: Calls
LogUtil.getAllLogFiles()
on mount via
LaunchedEffect
Displays List
: Uses
LazyColumn
with
items(logFiles)
iterator
Actions Per File
:
Tap
: Opens
LogDetailDialog
showing full file content
Share Icon
: Calls
shareLogFile(context, file)
helper
Share Implementation
This uses Android's
FileProvider
to safely expose log files to external apps, requiring configuration in the manifest (see Build Configuration documentation for provider setup).
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
294-336
State Management Pattern
Local State Initialization
All editable settings use the
read-on-mount pattern
:
This creates
local copies
of configuration, decoupling UI state from global state until disposal.
Cross-Component State Dependencies
UI Element
Data Source
Type
Save Location Dropdown
LibraryViewModel.allLibraries
StateFlow
Version Display
BuildConfig.VERSION_NAME
Constant
Latest Notice
NoticeManager.getLatestNotice()
Suspend Function
The
LibraryViewModel
is instantiated within the composable
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
82-84
:
Save Location Logic Flow
Diagram: Save Location Selection Flow
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
46-51
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
183-200
Configuration Access Patterns
From LibraryViewModel
The ViewModel accesses configuration during AI operations:
References:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
338-341
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
358
From Network Layer
The
RetrofitClient
uses
AppConfig.serverUrl
as the base URL for AI API calls. When Key-Kit verification updates
ai_base_url
in SharedPreferences, the app must reload
AppConfig
to apply the new endpoint.
Configuration Validation
The
isConfigured()
method
app/src/main/java/com/magicword/app/utils/AppConfig.kt
57-59
provides a simple check:
This is used during app initialization to determine if setup is required.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
308-379
app/src/main/java/com/magicword/app/utils/AppConfig.kt
57-59
UI Layout Structure
Screen Composition
Diagram: SettingsScreen Layout Hierarchy
Divider Usage
Divider
components
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
149-226
visually separate logical sections with vertical padding:
Section Titles
Section headers use
MaterialTheme.typography.titleSmall
with primary color:
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
95-264
Related Components
UpdateDialog Component
A reusable
AlertDialog
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
273-281
that displays:
Title
: "发现新版本 v{version}"
Content
: Scrollable release notes from
UpdateInfo.releaseNotes
Actions
:
"立即更新" → Opens download URL in browser
"稍后" → Dismisses dialog
AboutDialog Component
A simple informational dialog
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
284-291
showing app version and author credits.
LogDetailDialog Component
A read-only text viewer
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
322-329
displaying full log file contents in a scrollable
Column
.
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
273-329
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
SettingsScreen & Configuration
Purpose and Scope
Architecture Overview
AppConfig Singleton
Configuration Properties
Initialization
Persistence
Key-Kit Verification System
Implementation Details
UI State Management
Configuration Categories
AI Configuration Section
Personalization Section
System Preferences Section
Links & About Section
Persistence Mechanism
Two-Tier SharedPreferences Architecture
Save Trigger
Data Flow Summary
Update Management Integration
UI State Variables
Log Management UI
LogListScreen Component
Share Implementation
State Management Pattern
Local State Initialization
Cross-Component State Dependencies
Save Location Logic Flow
Configuration Access Patterns
From LibraryViewModel
From Network Layer
Configuration Validation
UI Layout Structure
Screen Composition
Divider Usage
Section Titles
Related Components
UpdateDialog Component
AboutDialog Component
LogDetailDialog Component

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.3-feature-systems

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Feature Systems
Relevant source files
LICENSE
README.md
README_EN.md
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
Purpose and Scope
This document provides an overview of the major feature implementations in MagicWord that span multiple components and layers. These features represent the core value propositions of the application and involve complex interactions between the UI, business logic, data persistence, and external services.
The three primary feature systems are:
AI Integration
- Word definition fetching, bulk text extraction, and mnemonic generation
Spaced Repetition System (SM-2)
- Scientific review scheduling and memory optimization
Update System
- Self-updating mechanism for APK distribution
For detailed implementation of each system, see:
AI Integration:
2.3.1
Spaced Repetition System:
2.3.2
Update System:
2.3.3
For information about the UI screens that expose these features, see
2.2
. For core data management, see
2.1
.
Feature System Architecture Overview
The three major feature systems are orchestrated primarily through
LibraryViewModel
, which serves as the central coordinator. Each system has distinct data flows and dependencies but shares common infrastructure.
High-Level Feature System Interactions
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1200
README.md
1-218
AI Integration System
The AI Integration system provides three primary capabilities: single word lookup with automatic import, bulk text extraction with parallel processing, and enhanced learning through AI-generated mnemonics and examples.
AI System Architecture
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
282-380
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-924
AI Integration Key Components
Component
Type
Purpose
Key Methods
handleGlobalSearch
Function
Orchestrates word lookup and import
Lines 282-306
importSingleWord
Suspend Function
AI-powered single word import
Lines 308-380
bulkImport
Function
Extract and import words from text
Lines 698-815
processChunk
Suspend Function
Process word batches with retry
Lines 817-865
fetchWordDefinitionsFromAi
Suspend Function
Request definitions for word list
Lines 867-917
RetrofitClient
Singleton
AI API client
Referenced in network layer
AppConfig
Singleton
AI model configuration
Lines 49, 338, 869
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1200
Bulk Import Processing Flow
The bulk import feature implements a sophisticated multi-stage pipeline with parallel processing and automatic retry logic:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-815
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
817-865
AI Request Configuration
The system uses
AppConfig
singleton for model configuration and supports user persona customization:
Model Name
:
AppConfig.modelName
(default: Qwen2.5-7B-Instruct)
Temperature
: 0.3 for single word, 0.1 for extraction, 0.3 for bulk definitions
User Persona
:
AppConfig.userPersona
- injected into prompts to customize examples and mnemonics
Save Location
:
AppConfig.saveLocationId
- determines target library for imported words
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
49
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
338
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
869-871
Parallel Processing Strategy
The bulk import uses controlled concurrency to balance speed and stability:
Chunking
: Words divided into groups of 3 (
LibraryViewModel.kt
759
)
Batch Processing
: Up to 3 chunks processed in parallel (
LibraryViewModel.kt
775
)
Retry Queue
: Failed chunks re-queued with incremented retry count (
LibraryViewModel.kt
858
)
Max Retries
: Each chunk attempted up to 3 times (
LibraryViewModel.kt
762
)
Synchronized Set
: Thread-safe tracking of imported words (
LibraryViewModel.kt
766
)
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
759-790
Spaced Repetition System (SM-2)
The SM-2 algorithm implementation provides scientifically-optimized review scheduling based on user performance. The system tracks repetitions, intervals, and easiness factors for each word.
SM-2 System Architecture
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
SM-2 Algorithm Implementation
The core SM-2 logic in
processReview
follows the SuperMemo-2 specification with specific handling for forgotten words:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
SM-2 Data Model
The
Word
entity contains all fields necessary for SM-2 tracking:
Field
Type
Purpose
Default Value
repetitions
Int
Number of consecutive correct reviews
0
interval
Int
Days until next review
1
easinessFactor
Float
Difficulty multiplier
2.5f
nextReviewTime
Long
Timestamp (ms) of next review
0
lastReviewTime
Long
Timestamp (ms) of last review
0
reviewCount
Int
Total review attempts
0
correctCount
Int
Number of correct reviews
0
incorrectCount
Int
Number of incorrect reviews
0
Sources:
Referenced in
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
152-161
Due Words Query System
The system uses Kotlin Flow operators to reactively compute due words based on selected libraries:
Flow Composition:
combine
- Merges
currentLibraryId
and
studyLibraryIds
StateFlows
Fallback Logic
- Uses current library if no libraries selected
flatMapLatest
- Switches to new query when selection changes
getDueWordsForLibraries
- Room query filters by
nextReviewTime <= now
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
Study Library Selection
Users can select multiple libraries for combined study sessions:
Function
Purpose
Persistence
toggleStudyLibrary(libraryId)
Add/remove library from selection
SharedPreferences
setStudyLibraries(ids)
Set entire selection
SharedPreferences
saveStudyLibraryIds(ids)
Persist to
study_library_ids
key
SharedPreferences
The selection is validated on ViewModel initialization to remove deleted libraries (
LibraryViewModel.kt
184-199
).
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
173-219
Update System
The Update System enables self-updating APK distribution, critical for users behind network restrictions that prevent access to standard app stores. The system checks GitHub Releases via Cloudflare proxy.
Update System Architecture
Sources:
README.md
71-72
Referenced in MainScreen initialization
Update Check Flow
The update system follows this sequence:
Trigger
: MainScreen's
LaunchedEffect
on first composition
API Call
: Request to Cloudflare proxy endpoint
Version Comparison
: Parse
versionCode
from Release tag_name
User Prompt
: Display dialog with release notes if newer version available
Download
: Stream APK to app cache directory
Installation
: Use FileProvider to grant URI permission and launch install intent
Proxy Configuration:
Base URL:
https://mag.upxuu.com
Endpoint:
/api/repos/lijiaxu2021/MagicWord/releases/latest
Fallback: Direct GitHub API if proxy fails
Sources:
README.md
44-48
README.md
71-72
Skip Version Mechanism
Users can dismiss update prompts, which persists the skipped version:
SharedPreferences Key
Value
Purpose
skip_update_version
Int (versionCode)
Prevents re-prompting for same version
This is cleared when:
User manually checks for updates in Settings
App is updated through other means
Sources:
Referenced in update system logic
APK Download and Installation
The system uses Android's FileProvider for secure APK installation on Android 8.0+:
Download Location
:
context.cacheDir
or
context.getExternalFilesDir(null)
FileProvider Authority
: Configured in AndroidManifest.xml
Intent Flags
:
FLAG_GRANT_READ_URI_PERMISSION
+
FLAG_ACTIVITY_NEW_TASK
MIME Type
:
application/vnd.android.package-archive
Permission Requirements:
REQUEST_INSTALL_PACKAGES
permission (Android 8.0+)
Runtime permission request if not granted
Sources:
README.md
71-72
Referenced in UpdateManager implementation
Feature System Integration Points
All three feature systems integrate at specific points in the application lifecycle:
Integration Map
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1200
Shared Infrastructure
All three systems rely on common infrastructure components:
Component
Used By
Purpose
LibraryViewModel
AI, SM-2
State management and orchestration
WordDao
AI, SM-2
Database CRUD operations
SharedPreferences
SM-2, Update
Lightweight persistence
OkHttpClient
AI (via Retrofit), Update
Network communication
viewModelScope
All
Coroutine lifecycle management
StateFlow
All
Reactive UI state emissions
LogUtil
All
Error tracking and debugging
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1200
Error Handling Patterns
Each system implements error handling appropriate to its domain:
AI Integration:
Retry logic with exponential backoff (
LibraryViewModel.kt
568-579
)
Queue-based failure recovery (
LibraryViewModel.kt
856-861
)
User-visible logs via
_importLogs
StateFlow
SM-2 System:
Silent failure with data integrity preservation
Validation on initialization (
LibraryViewModel.kt
184-199
)
Graceful degradation if database unavailable
Update System:
Network timeout handling
Fallback to direct GitHub API
User dismissal with skip tracking
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
568-579
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
856-861
Summary
The three major feature systems represent distinct domains but share architectural patterns:
Centralized Orchestration
: All managed through
LibraryViewModel
Reactive State
: Extensive use of Kotlin Flow and StateFlow
Error Resilience
: Retry logic, validation, and graceful degradation
User Feedback
: Real-time loading states and result emissions
Each system is designed to operate independently while leveraging shared infrastructure, enabling modular testing and maintenance.
For implementation details of each system, see their respective child pages:
2.3.1
,
2.3.2
, and
2.3.3
.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1200
README.md
1-218
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Feature Systems
Purpose and Scope
Feature System Architecture Overview
High-Level Feature System Interactions
AI Integration System
AI System Architecture
AI Integration Key Components
Bulk Import Processing Flow
AI Request Configuration
Parallel Processing Strategy
Spaced Repetition System (SM-2)
SM-2 System Architecture
SM-2 Algorithm Implementation
SM-2 Data Model
Due Words Query System
Study Library Selection
Update System
Update System Architecture
Update Check Flow
Skip Version Mechanism
APK Download and Installation
Feature System Integration Points
Integration Map
Shared Infrastructure
Error Handling Patterns
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.3.1-ai-integration

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
AI Integration
Relevant source files
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
app/src/main/java/com/magicword/app/utils/AppConfig.kt
Purpose and Scope
This document covers the AI-powered features in MagicWord that enable automatic vocabulary acquisition and definition generation. The system uses external AI APIs (primarily Qwen models via SiliconFlow) to provide:
Single Word Import
: AI-driven word definition lookup triggered by global search
Bulk Text Import
: Extracting and processing multiple words from text passages
Mnemonic Generation
: AI-generated memory aids and example sentences
For spaced repetition learning logic that uses these imported words, see
Spaced Repetition System (SM-2)
. For the UI screens that expose these features, see
WordsScreen
and
SettingsScreen
.
System Architecture
AI Integration Flow
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
1-1200
app/src/main/java/com/magicword/app/utils/AppConfig.kt
1-61
Configuration Management
AppConfig Singleton
The
AppConfig
object centralizes AI-related configuration with persistent storage:
Property
Type
Default
Purpose
apiKey
String
""
API authentication key
modelName
String
"Qwen/Qwen2.5-7B-Instruct"
AI model identifier
serverUrl
String
""
Base URL for AI service
userPersona
String
""
User context for personalized examples
saveLocationId
Int
-1
Target library for imported words (-1 = current)
Initialization Flow:
Sources:
app/src/main/java/com/magicword/app/utils/AppConfig.kt
28-35
Key-Kit Verification System
The application supports server-managed configuration through a "Key-Kit" verification mechanism that allows users to retrieve pre-configured API credentials:
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
52-147
Feature: Single Word Import
Global Search Workflow
The
handleGlobalSearch()
function implements an intelligent search-or-import pattern:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
282-306
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
308-380
AI Prompt Structure for Single Word
The system uses a meticulously crafted prompt to ensure structured JSON responses:
Key Requirements:
LEMMA form
: Input "ran" → Output "run"
Variable sense count
: Only include actual meanings (not forced to 10)
Phrase handling
: Preserve underscores ("give_up")
Strict JSON
: No markdown, no trailing commas
Prompt Template:
You are a strict JSON data generator. Analyze this English word: "$text"

Return a SINGLE JSON Object (NOT Array).

STRICT JSON FORMAT RULES:
1. "word": String (The LEMMA/ROOT form)
2. "phonetic": String
3. "senses": Object (Key-Value pairs)
   - Keys: "sense_1", "sense_2", etc.
   - Value: { "pos": "...", "meaning": "..." }
4. "definition_en": String
5. "example": String (Format: "En sentence. Cn translation.")
6. "memory_method": String
7. "forms": Object or null
   - "past", "participle", "plural", "third_person"

IMPORTANT: Valid JSON syntax. No trailing commas.
NO MARKDOWN. NO COMMENTS. ONLY JSON.
Response Parsing Logic:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
310-379
Feature: Bulk Text Import
Multi-Stage Processing Pipeline
The
bulkImport()
function implements a sophisticated chunked processing system with retry logic:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
698-815
Chunked Processing Implementation
Chunk Queue Structure:
Concurrency Control:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
758-790
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
817-865
Phrase Handling Strategy
To prevent multi-word phrases from being split during processing:
Stage
Input
Output
Reason
Step A Prompt
"give up"
"give_up"
AI instructed to use underscores
Chunk Processing
"give_up"
AI receives "give_up"
Preserved through array
AI Response
"give_up"
stdWord.word = "give_up"
AI may keep or convert
Database Insert
"give_up"
word.word = "give up"
replace("_", " ")
applied
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
707-719
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
841-849
AI Prompt Engineering
Batch Definition Prompt
The
fetchWordDefinitionsFromAi()
function constructs prompts for processing word chunks:
User Persona Integration:
Prompt Structure:
You are a strict JSON data generator. Analyze these English words: $words
$personaInstruction
Return a JSON Array of objects.

STRICT JSON FORMAT RULES:
1. "word": String (LEMMA/ROOT form)
2. "phonetic": String
3. "senses": Object (Key-Value pairs)
   - "sense_1", "sense_2", etc.
   - Value: { "pos": "...", "meaning": "..." }
4. "definition_en": String
5. "example": String (Format: "En sentence. Cn translation.")
6. "memory_method": String
7. "forms": Object (Word Variations) or null

IMPORTANT: Valid JSON syntax. No trailing commas.
NO MARKDOWN. NO COMMENTS. ONLY JSON.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
867-917
StandardizedWord Data Structure
The AI response is parsed into this intermediate structure before database insertion:
Conversion Logic:
The
toEntity()
extension function flattens the
senses
map into a single
definitionCn
string by concatenating all meanings with their part-of-speech labels.
Sources:
app/src/main/java/com/magicword/app/data/Word.kt
(referenced in LibraryViewModel)
Error Handling and Retry Mechanisms
Three-Layer Retry Strategy
Retry Helper Implementation:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
568-579
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
728-732
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
855-863
Progress Tracking and User Feedback
The system provides real-time feedback through
StateFlow<List<String>>
:
UI Implementation:
Sources:
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
672-726
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
462-466
Network Layer Integration
RetrofitClient Configuration
The AI service is accessed through a Retrofit interface with dynamic configuration:
Authorization Interceptor:
API Endpoint:
Sources:
app/src/main/java/com/magicword/app/network/RetrofitClient.kt
(inferred from usage in LibraryViewModel)
Configuration UI
Settings Screen AI Section
The
SettingsScreen
provides a comprehensive interface for AI configuration:
Key-Kit Section:
Manual Configuration Fields:
Field
Property
Editable
Description
API Key
apiKey
Read-only
Protected field for security
Model Name
modelName
Yes
Can override model selection
User Persona
userPersona
Yes
Multi-line context description
Save Location
saveLocationId
Yes
Dropdown of available libraries
Sources:
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
106-200
Performance Considerations
Chunking Strategy
Rationale for chunkSize=3:
Performance Metrics:
Sequential processing
: 3 words × 3 batches = 9 words per batch cycle
Network utilization
: 3 concurrent HTTP requests
Retry buffer
: Failed chunks don't block progress
Temperature Settings:
Use Case
Temperature
Reason
Word Extraction (Step A)
0.1
Deterministic list extraction
Definition Generation (Step B)
0.3
Balanced creativity for examples
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
759
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
724
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
903
Summary
The AI Integration system provides a robust, user-friendly pipeline for vocabulary acquisition through:
Intelligent Search-Import
: Dual-mode global search that falls back to AI import
Chunked Bulk Processing
: Parallel, fault-tolerant batch processing with retry queues
Structured Prompting
: Strict JSON format requirements ensuring consistent parsing
User Personalization
: Persona-aware examples and mnemonics
Flexible Configuration
: Key-Kit system for managed setup or manual configuration
Key Implementation Files:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
282-917
- Core AI logic
app/src/main/java/com/magicword/app/ui/WordsScreen.kt
672-726
- Bulk import UI
app/src/main/java/com/magicword/app/utils/AppConfig.kt
1-61
- Configuration management
app/src/main/java/com/magicword/app/ui/SettingsScreen.kt
106-200
- Settings UI
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
AI Integration
Purpose and Scope
System Architecture
AI Integration Flow
Configuration Management
AppConfig Singleton
Key-Kit Verification System
Feature: Single Word Import
Global Search Workflow
AI Prompt Structure for Single Word
Feature: Bulk Text Import
Multi-Stage Processing Pipeline
Chunked Processing Implementation
Phrase Handling Strategy
AI Prompt Engineering
Batch Definition Prompt
StandardizedWord Data Structure
Error Handling and Retry Mechanisms
Three-Layer Retry Strategy
Progress Tracking and User Feedback
Network Layer Integration
RetrofitClient Configuration
Configuration UI
Settings Screen AI Section
Performance Considerations
Chunking Strategy
Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.3.2-spaced-repetition-system-(sm-2)

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Spaced Repetition System (SM-2)
Relevant source files
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
app/src/main/java/com/magicword/app/ui/WordCard.kt
Purpose and Scope
This document describes the implementation of the SuperMemo-2 (SM-2) spaced repetition algorithm in MagicWord, which optimizes vocabulary review scheduling based on user performance. The system automatically calculates when each word should be reviewed next, adapting intervals based on how easily the user recalls the word.
For information about the general learning and testing features, see
Learning & Testing
. For details on the study user interface, see
StudyScreen - Spaced Repetition Review
.
Algorithm Overview
The SM-2 algorithm is a scientifically-backed spaced repetition method that determines optimal review intervals for vocabulary words. The core principle is that correctly recalled items should be reviewed at progressively longer intervals, while forgotten items should be reset to short intervals.
Key Parameters
The algorithm maintains three primary state variables per word:
Parameter
Symbol
Initial Value
Range
Description
Repetitions
n
0
0 to ∞
Count of consecutive successful reviews (quality ≥ 3)
Interval
I
1
1 to ∞
Days until next review
Easiness Factor
EF
2.5
1.3 to ∞
Multiplier for interval growth, adjusted by performance
State Transitions
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
Data Model
The SM-2 algorithm state is persisted in the
Word
entity within the Room database. The relevant fields are:
Field
Type
Purpose
repetitions
Int
Consecutive successful reviews counter (resets on failure)
interval
Int
Days until next review
easinessFactor
Float
Interval growth multiplier (default 2.5)
nextReviewTime
Long
Unix timestamp (milliseconds) when word becomes due
lastReviewTime
Long
Unix timestamp of most recent review
reviewCount
Int
Total number of reviews (successful + failed)
correctCount
Int
Number of successful reviews (quality ≥ 3)
incorrectCount
Int
Number of failed reviews (quality < 3)
Database Schema Integration
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
6
app/src/main/java/com/magicword/app/data/Word.kt
Implementation Details
Core Algorithm Function
The SM-2 algorithm is implemented in
LibraryViewModel.processReview()
. This function takes two parameters:
word: Word
- The word being reviewed
quality: Int
- User's self-assessment rating (0-5)
Algorithm Logic
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
Code Implementation
The function executes within a coroutine scope and performs database updates asynchronously:
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
115-165
Quality Rating System
Users rate their recall performance on a 6-point scale (0-5), which directly influences the algorithm's behavior:
Quality
Label
Color
Meaning
Algorithm Effect
0
忘记 (Forgotten)
Red (#E57373)
Complete blackout, no recall
Reset:
repetitions=0
,
interval=1
1-2
(Not Used)
-
Incorrect with hesitation
Same as quality 0
3
困难 (Difficult)
Orange (#FFB74D)
Correct after significant hesitation
Advance with EF penalty: EF' = EF - 0.14
4
良好 (Good)
Green (#81C784)
Correct after slight hesitation
Advance with EF boost: EF' = EF + 0.0
5
简单 (Easy)
Blue (#64B5F6)
Perfect recall, immediate
Advance with EF boost: EF' = EF + 0.1
Easiness Factor Formula
The easiness factor adjustment formula is:
EF' = EF + (0.1 - (5 - q) × (0.08 + (5 - q) × 0.02))
Where
q
is the quality rating (0-5).
EF Adjustment Examples
Quality (q)
q Factor (5-q)
EF Change
Example (EF=2.5)
New EF
5 (Easy)
0
+0.10
2.5 + 0.10
2.60
4 (Good)
1
0.00
2.5 + 0.00
2.50
3 (Difficult)
2
-0.14
2.5 - 0.14
2.36
0 (Forgotten)
5
-0.80
2.5 - 0.80
1.70
(but repetitions reset)
Note:
The minimum EF is clamped to 1.3 to prevent intervals from shrinking indefinitely.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
145-147
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
340-344
User Interaction Flow
Study Session Lifecycle
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
40-468
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
Due Words Query
The system uses a reactive Flow-based query to fetch words that are due for review:
The query logic ensures that:
If the user has selected specific libraries for study, only words from those libraries are included
If no libraries are selected, the current library is used as a fallback
Only words with
nextReviewTime <= System.currentTimeMillis()
are returned
The Flow automatically updates when words are reviewed or new words become due
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
236-242
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
53
Review Button Implementation
The review interface provides four quality levels through dedicated buttons in the
StudyScreen
:
The
processResult
helper function coordinates the review action:
Sources:
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
446-467
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
335-353
Statistics and Progress Tracking
Displayed Metrics
The word detail view displays comprehensive statistics that reflect SM-2 state:
Metric
Calculation
Display Location
学习次数
(Review Count)
word.reviewCount
WordCard statistics section
正确率
(Correct Rate)
(correctCount × 100 / reviewCount)%
WordCard (green if > 0)
下次复习
(Next Review)
Date(nextReviewTime)
or "Now" if due
WordCard statistics section
录入时间
(Created At)
Date(createdAt)
WordCard statistics section
上次复习
(Last Review)
Date(lastReviewTime)
(if > 0)
WordCard statistics section
Progress Indicator
During study sessions, a
LinearProgressIndicator
shows completion progress:
progress = (currentWordIndex + 1) / dueWords.size
Sources:
app/src/main/java/com/magicword/app/ui/WordCard.kt
274-308
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
250-254
Integration Points
Component Diagram
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
app/src/main/java/com/magicword/app/data/WordDao.kt
Edge Cases and Special Behaviors
Global Search Reset
When a user searches for a word globally and it exists in the database, the system treats this as a "forgotten" event:
This ensures that looking up a word resets its review schedule, as the user presumably couldn't recall it naturally.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
289-295
New Word Initialization
When words are imported (either through AI or JSON import), they are initialized with default SM-2 values:
This makes new words immediately available for review.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
364-369
Multi-Library Study
The system supports studying words from multiple libraries simultaneously. The user can select library combinations through a dialog in
StudyScreen
, and the selection is persisted to SharedPreferences:
The
dueWords
Flow combines the selected library IDs and queries words from all of them, mixing them in the study session.
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
173-219
app/src/main/java/com/magicword/app/ui/StudyScreen.kt
162-175
Performance Characteristics
Time Complexity
Operation
Complexity
Notes
processReview()
O(1)
Single database update
getDueWordsForLibraries()
O(n log n)
Indexed query on
nextReviewTime
Quality calculation
O(1)
Simple arithmetic operations
Interval Growth Examples
For a word with default EF=2.5 and consistently good performance (quality=4):
Review #
Repetitions
Interval
Next Review
1 (Initial)
1
1 day
Tomorrow
2
2
6 days
1 week later
3
3
15 days
2 weeks later
4
4
38 days
~5 weeks later
5
5
95 days
~3 months later
6
6
238 days
~8 months later
Sources:
app/src/main/java/com/magicword/app/ui/LibraryViewModel.kt
136-141
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Spaced Repetition System (SM-2)
Purpose and Scope
Algorithm Overview
Key Parameters
State Transitions
Data Model
Database Schema Integration
Implementation Details
Core Algorithm Function
Algorithm Logic
Code Implementation
Quality Rating System
Easiness Factor Formula
EF Adjustment Examples
User Interaction Flow
Study Session Lifecycle
Due Words Query
Review Button Implementation
Statistics and Progress Tracking
Displayed Metrics
Progress Indicator
Integration Points
Component Diagram
Edge Cases and Special Behaviors
Global Search Reset
New Word Initialization
Multi-Library Study
Performance Characteristics
Time Complexity
Interval Growth Examples

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/2.3.3-update-system

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Update System
Relevant source files
app/src/main/java/com/magicword/app/ui/MainScreen.kt
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
Purpose and Scope
The Update System provides in-app update functionality that enables MagicWord to distribute new versions directly to users without requiring app store approval. This is critical for users in regions with network restrictions or where accessing Google Play is difficult. The system checks for updates from GitHub Releases, downloads APK files through the Cloudflare Worker proxy, and handles installation with proper permission management for Android 8.0+.
For information about the Cloudflare Worker's role in proxying GitHub API requests, see
Cloudflare Worker - API Gateway
. For details on the overall system architecture and cloud infrastructure, see
System Architecture
.
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
1-170
app/src/main/java/com/magicword/app/ui/MainScreen.kt
82-177
Architecture Overview
The Update System implements a three-tier architecture that bypasses traditional app store distribution channels:
Key Characteristics:
Serverless Distribution
: No dedicated update server; GitHub Releases serves as the distribution platform
Proxy-Based Access
: All GitHub API calls route through Cloudflare to solve CORS and regional access issues
Progress Tracking
: Real-time download progress with UI feedback
Permission-Safe Installation
: Automatic handling of Android 8.0+ unknown source restrictions
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
16-23
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
Core Components
UpdateManager Singleton
UpdateManager
is a Kotlin object (singleton) located at
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
that centralizes all update-related operations.
Configuration Constants:
Constant
Value
Purpose
PROXY_BASE_URL
"https://mag.upxuu.com"
Cloudflare Worker base URL
GITHUB_OWNER
"lijiaxu2021"
Repository owner
GITHUB_REPO
"MagicWord"
Repository name
LATEST_RELEASE_URL
$PROXY_BASE_URL/api/repos/$GITHUB_OWNER/$GITHUB_REPO/releases/latest
Full API endpoint
OkHttpClient Configuration:
- connectTimeout: 15 seconds
- readTimeout: 30 seconds
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
16-27
Update Information Data Models
The system uses three data classes for update information:
UpdateInfo
: User-facing update metadata returned by
checkUpdate()
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
29-34
ReleaseResponse
: GitHub API response structure deserialized via Gson
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
159-163
Asset
: Individual files attached to a GitHub release
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
165-168
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
29-168
Update Detection Flow
Check Update Process
The
checkUpdate()
function implements version comparison against GitHub Releases:
Version Comparison Algorithm:
The
compareVersions()
function at
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
70-81
implements semantic version comparison:
Split version strings by
.
delimiter (e.g., "1.2.3" → [1, 2, 3])
Parse each component as integer (non-numeric treated as 0)
Compare component-by-component until difference found
Return: positive if v1 > v2, negative if v1 < v2, zero if equal
Download URL Construction:
When a new version is detected, the download URL is set to
"$PROXY_BASE_URL/MagicWordLatest.apk"
rather than using the GitHub asset's
browser_download_url
. This ensures the download routes through the Cloudflare proxy for consistent access.
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
52-55
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
36-81
APK Download Process
Download with Progress Tracking
The
downloadApk()
function handles large file downloads with real-time progress callbacks:
Implementation Details:
Buffer Size
: 8 KB (8 * 1024 bytes) for efficient memory usage
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
98
Destination
:
externalCacheDir/update.apk
managed by caller
Progress Calculation
:
(totalRead * 100 / totalLength).toInt()
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
106
Error Handling
: Returns
false
on any exception, with stacktrace printed
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
83-118
APK Installation Flow
Permission Handling for Android 8.0+
The
installApk()
function implements a two-stage permission check required for Android 8.0 (API 26) and above:
Permission Strategy:
Pre-Android 8.0
(API < 26): No special permission required; proceed directly to installation
Android 8.0+
(API ≥ 26):
Check
PackageManager.canRequestPackageInstalls()
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
124
If denied, launch system settings with
ACTION_MANAGE_UNKNOWN_APP_SOURCES
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
127
Return early; user must manually click update again after granting permission
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
135
FileProvider Configuration:
The installation uses Android FileProvider to securely expose the APK file:
Authority
:
${BuildConfig.APPLICATION_ID}.provider
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
143-144
File Location
: Passed as parameter, typically
externalCacheDir/update.apk
URI Flags
:
FLAG_GRANT_READ_URI_PERMISSION
allows installer to read the file
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
149
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
120-157
UI Integration
MainScreen Update Dialog
The update system integrates into
MainScreen
through reactive state management and coroutine-based download handling:
State Variables:
Variable
Type
Purpose
showUpdateDialog
Boolean
Controls dialog visibility
updateInfo
UpdateInfo?
Holds update metadata
downloadProgress
Int
Current download percentage (0-100)
isDownloading
Boolean
Prevents dialog dismissal during download
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
83-86
Update Check on Launch
The check happens in a
LaunchedEffect(Unit)
block at
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-98
executing once on initial composition. This occurs alongside the notice check system.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
92-106
Download and Install Dialog
The
AlertDialog
at
app/src/main/java/com/magicword/app/ui/MainScreen.kt
127-177
provides a complete update flow:
Dialog Components:
Title
: Displays new version number:
"New Version Available: v${updateInfo.version}"
Text Content
:
Release notes from GitHub
Linear progress indicator (visible only during download)
Progress percentage text:
"Downloading... $downloadProgress%"
Confirm Button
("Update Now"):
Disabled during download
Triggers coroutine-based download flow
Dismiss Button
("Later"):
Hidden during download to prevent cancellation
Allows user to defer update
Download Flow Implementation:
The progress callback
{ progress -> downloadProgress = progress }
triggers Compose recomposition on each progress update, animating the
LinearProgressIndicator
from 0% to 100%.
Sources:
app/src/main/java/com/magicword/app/ui/MainScreen.kt
127-177
Error Handling and Edge Cases
Network Failures
All network operations in
UpdateManager
implement try-catch blocks:
Update Check Failure
: Returns
null
from
checkUpdate()
, preventing dialog display
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
63-66
Download Failure
: Returns
false
from
downloadApk()
, preventing installation attempt
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
113-116
Stack Traces
: Errors print to logcat via
e.printStackTrace()
for debugging
Installation Edge Cases
Scenario
Behavior
Android 8.0+ without permission
Opens system settings; returns early
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
127-135
User cancels permission dialog
No automatic retry; user must click "Update Now" again
FileProvider misconfiguration
Installation crashes; caught by try-catch
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
152-156
Corrupted APK download
Android Package Installer displays error; not handled by app
Version Comparison Edge Cases
The
compareVersions()
function handles:
Non-numeric components
: Treated as 0 (e.g., "1.2.beta" → [1, 2, 0])
Mismatched lengths
: "1.2" vs "1.2.3" → pads shorter with zeros
"v" prefix
: Stripped via
removePrefix("v")
before comparison
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
47
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
63-157
app/src/main/java/com/magicword/app/ui/MainScreen.kt
148-163
Data Flow Summary
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
1-170
app/src/main/java/com/magicword/app/ui/MainScreen.kt
82-177
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Update System
Purpose and Scope
Architecture Overview
Core Components
UpdateManager Singleton
Update Information Data Models
Update Detection Flow
Check Update Process
APK Download Process
Download with Progress Tracking
APK Installation Flow
Permission Handling for Android 8.0+
UI Integration
MainScreen Update Dialog
Update Check on Launch
Download and Install Dialog
Error Handling and Edge Cases
Network Failures
Installation Edge Cases
Version Comparison Edge Cases
Data Flow Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/3-cloud-infrastructure

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Cloud Infrastructure
Relevant source files
LICENSE
README.md
README_EN.md
cf.js
verify_online_api.py
verify_proxy.py
This document covers the serverless backend architecture of MagicWord, which uses Cloudflare Workers as an API gateway and GitHub repositories as data storage. The system eliminates the need for traditional backend servers while providing CORS proxying, file distribution, and community-driven vocabulary library sharing.
For details about the Android application's interaction with cloud services, see
Android Application
. For deployment and CI/CD configuration, see
Development & Deployment
.
Architecture Overview
MagicWord employs a
serverless three-tier architecture
that leverages edge computing and version control systems as infrastructure:
Cloudflare Worker
- Acts as the API gateway and CORS proxy
GitHub Application Repository
(
lijiaxu2021/MagicWord
) - Stores APK releases and system notices
GitHub Data Repository
(
lijiaxu2021/magicwordfile
) - Serves as the vocabulary library warehouse with automated indexing
Key Design Decisions
:
No backend server
: All compute happens at the edge (Cloudflare) or via GitHub Actions
GitHub as database
: Libraries stored as JSON files, leveraging Git's versioning and CDN distribution
CORS proxy
: Cloudflare Worker solves cross-origin issues when accessing GitHub Raw content
Automatic indexing
: GitHub Actions regenerate catalog metadata on every library upload
Sources
:
cf.js
1-239
README.md
24-43
Cloudflare Worker Gateway
The Cloudflare Worker script (
cf.js
) is deployed at
mag.upxuu.com
and serves as the universal entry point for all Android client requests.
Route Mapping and Handler Functions
Sources
:
cf.js
39-85
Configuration Constants
The worker uses the following configuration defined at the top of
cf.js
6-28
:
Constant
Value
Purpose
GH_USERNAME
"lijiaxu2021"
GitHub account owner
GH_REPO_APP
"MagicWord"
Main application repository
GH_REPO_DATA
"magicwordfile"
Data warehouse repository
GH_BRANCH
"main"
Target branch for all operations
RAW_BASE
"https://raw.githubusercontent.com"
GitHub Raw content CDN
GITHUB_TOKEN
Environment variable or placeholder
Personal access token for write operations
TARGET_API_DOMAIN
"api.github.com"
GitHub REST API endpoint
The
URL_APK
,
URL_NOTICE
, and
URL_LIB_INDEX
constants are automatically constructed using template literals to point to the respective files in the GitHub repositories.
Sources
:
cf.js
6-28
Route Implementation Details
Route 1: APK Distribution
Implementation at
cf.js
43-46
calls
fetchRawFile(URL_APK, "application/vnd.android.package-archive", 'attachment; filename="MagicWordLatest.apk"')
. The function adds a timestamp query parameter to bypass Cloudflare edge cache
cf.js
98
Sources
:
cf.js
43-46
cf.js
95-121
Route 2: System Notices
Handles requests to
/notice.json
by proxying to the main repository's notice file
cf.js
49-51
Returns JSON with CORS headers enabled.
Sources
:
cf.js
49-51
Route 3: Library Index and File Proxy
This route serves two purposes:
Index endpoint
(
/library/index.json
) - Legacy compatibility, proxies to
index.json
in the data repository
cf.js
55-58
File proxy
(
/library/file/*
) - Generic proxy for any file in
magicwordfile
repo, including:
index_0.json
,
index_1.json
, etc. (paginated library catalogs)
num.json
(pagination metadata)
tags.json
(tag statistics)
{timestamp}/info.json
(library metadata)
{timestamp}/library.json
(vocabulary words)
The proxy strips
/library/file/
prefix and constructs the GitHub Raw URL dynamically
cf.js
62-66
Sources
:
cf.js
55-66
Route 4: Library Upload Gateway
The POST endpoint
/library/upload
accepts JSON payloads and commits them to the data repository via GitHub's Contents API.
Upload Flow
:
The
handleLibraryUpload()
function
cf.js
126-176
:
Validates required fields (
name
,
contentBase64
)
Generates a timestamp-based ID using
Date.now().toString()
Creates
info.json
with metadata
cf.js
138-145
Base64-encodes
info.json
using UTF-8 safe encoding
cf.js
148-150
Calls
uploadToGithub()
twice for both files
cf.js
152-163
The
uploadToGithub()
function
cf.js
181-203
constructs GitHub Contents API requests with proper authorization headers.
Sources
:
cf.js
69-71
cf.js
126-203
Route 5: GitHub API Proxy
Generic proxy for GitHub REST API calls, primarily used for release checking. Strips
/api/
prefix and forwards to
api.github.com
cf.js
74-78
The
proxyRequest()
function
cf.js
208-238
:
Cleans Cloudflare-specific headers
cf.js
214
Sets
Access-Control-Allow-Origin: *
cf.js
226
Removes security policy headers that would block client usage
cf.js
229
Sources
:
cf.js
74-78
cf.js
208-238
CORS and Cache Handling
All proxy responses include CORS headers
cf.js
112
cf.js
167
cf.js
173
cf.js
226
Cache busting is implemented via timestamp query parameters
cf.js
98
to prevent stale content from edge caching.
Sources
:
cf.js
95-121
cf.js
208-238
GitHub Data Warehouse
The
lijiaxu2021/magicwordfile
repository serves as the persistent storage layer for community-contributed vocabulary libraries.
Repository Structure
magicwordfile/
├── .github/
│   └── workflows/
│       └── update_index.yml          # Auto-indexing workflow
├── index_0.json                       # Page 0 (latest libraries)
├── index_1.json                       # Page 1 (older libraries)
├── index_2.json                       # Page 2...
├── num.json                           # Pagination metadata
├── tags.json                          # Tag statistics
├── 1770900184827/                     # Library folder (timestamp ID)
│   ├── info.json                      # Metadata
│   └── library.json                   # Word list
├── 1770901234567/
│   ├── info.json
│   └── library.json
└── ...
Sources
:
README.md
102-113
File Formats
info.json
- Library Metadata
Generated by the Cloudflare Worker during upload
cf.js
138-145
:
library.json
- Word Collection
Contains an array of vocabulary entries in the format expected by the Android app's import logic. This is the Base64-encoded content from the upload request
cf.js
159
index_X.json
- Paginated Catalog
Generated by GitHub Actions, each page contains metadata for up to 10 libraries:
Sources
:
README.md
143-159
num.json
- Pagination Metadata
Tracks the current state of the catalog:
Sources
:
README.md
132-141
tags.json
- Tag Statistics
Aggregated tag counts across all libraries:
Sources
:
README.md
160-168
GitHub Actions Automation
The
update_index.yml
workflow is triggered on every push to the repository
README.md
116-124
It performs the following tasks:
The workflow ensures that the catalog metadata is always synchronized with the actual library files. Each library's
downloadUrl
in the index points to the Cloudflare Worker proxy endpoint, not directly to GitHub Raw, ensuring CORS compliance.
Sources
:
README.md
115-124
Update and Notice Distribution
The system provides two mechanisms for delivering information from the cloud to clients: application updates and system notices.
APK Distribution Flow
The update check uses the GitHub API proxy route
cf.js
74-78
to fetch release information, then downloads the APK via the dedicated APK route
cf.js
43-46
This dual-route approach ensures:
Version metadata is always fresh (API is not cached)
APK downloads bypass GitHub's rate limits and network restrictions
Sources
:
cf.js
43-46
cf.js
74-78
Notice System
The
notice.json
file
cf.js
49-51
in the main repository provides a mechanism for broadcasting announcements to all users:
The Android application fetches this file on startup and displays alerts if the
versionCode
field indicates the notice is relevant to the user's installed version. This allows for:
Critical security announcements
Deprecation warnings
Feature announcements
Service status updates
The notice is proxied through the Cloudflare Worker
cf.js
49-51
to ensure consistent delivery even in restricted network environments.
Sources
:
cf.js
49-51
README.md
182-192
Network Request Flow Summary
The complete request lifecycle from Android client to data retrieval:
All network traffic from the Android application flows through the Cloudflare Worker, which provides:
CORS header injection
for cross-origin requests
Caching bypass
via timestamp parameters
Network accessibility
in regions where GitHub may be restricted
Unified API surface
regardless of underlying GitHub structure changes
Sources
:
cf.js
31-35
cf.js
39-85
cf.js
95-121
Key Files
:
cf.js
1-239
- Complete Cloudflare Worker implementation
README.md
24-124
- Architecture overview and data warehouse documentation
verify_online_api.py
1-130
- API endpoint verification examples
verify_proxy.py
1-55
- Proxy functionality verification examples
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Cloud Infrastructure
Architecture Overview
Cloudflare Worker Gateway
Route Mapping and Handler Functions
Configuration Constants
Route Implementation Details
Route 1: APK Distribution
Route 2: System Notices
Route 3: Library Index and File Proxy
Route 4: Library Upload Gateway
Route 5: GitHub API Proxy
CORS and Cache Handling
GitHub Data Warehouse
Repository Structure
File Formats
`info.json` - Library Metadata
`library.json` - Word Collection
`index_X.json` - Paginated Catalog
`num.json` - Pagination Metadata
`tags.json` - Tag Statistics
GitHub Actions Automation
Update and Notice Distribution
APK Distribution Flow
Notice System
Network Request Flow Summary

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/3.1-cloudflare-worker-api-gateway

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Cloudflare Worker - API Gateway
Relevant source files
LICENSE
README.md
README_EN.md
cf.js
verify_online_api.py
verify_proxy.py
Purpose and Scope
This document provides comprehensive technical documentation of the Cloudflare Worker deployed at
mag.upxuu.com
, which serves as the central API gateway for the MagicWord system. The worker acts as a serverless proxy layer that enables the Android client to access GitHub-hosted resources, handles library uploads, and solves cross-origin resource sharing (CORS) restrictions.
For information about the GitHub data warehouse that this worker proxies, see
GitHub Data Warehouse
. For details about the Android client's network layer that consumes these APIs, see
Core Components
.
Sources:
cf.js
1-239
README.md
80-94
System Role and Responsibilities
The Cloudflare Worker serves four critical functions in the MagicWord architecture:
CORS Proxy
: Enables cross-origin access to GitHub Raw content for Android and web clients
Upload Gateway
: Receives library uploads from clients and commits them to the
magicwordfile
repository via GitHub API
Unified API Surface
: Provides a consistent API endpoint (
mag.upxuu.com
) abstracting multiple GitHub repositories
Network Accessibility
: Bypasses regional network restrictions by serving as an edge-deployed proxy
The worker is deployed on Cloudflare's global edge network, providing low-latency access worldwide without requiring traditional server infrastructure.
Sources:
cf.js
29-85
README.md
24-43
Configuration Constants
The worker uses a set of configuration constants to define GitHub repository endpoints and file paths. These are declared at the top of
cf.js
and can be modified for different deployment scenarios.
Constant
Value
Purpose
GH_USERNAME
"lijiaxu2021"
GitHub organization/user account
GH_REPO_APP
"MagicWord"
Main repository for application files (APK, notices)
GH_REPO_DATA
"magicwordfile"
Data warehouse for vocabulary libraries
GH_BRANCH
"main"
Git branch for all operations
RAW_BASE
"https://raw.githubusercontent.com"
Base URL for GitHub Raw content CDN
URL_APK
(computed)
Direct path to
MagicWordLatest.apk
URL_NOTICE
(computed)
Direct path to
notice.json
URL_LIB_INDEX
(computed)
Direct path to
index.json
(legacy)
GITHUB_TOKEN
(environment variable)
Personal access token for GitHub API write operations
TARGET_API_DOMAIN
"api.github.com"
GitHub REST API endpoint
The
GITHUB_TOKEN
is expected to be configured as a Cloudflare Worker environment variable (
GH_TOKEN
) rather than hardcoded, following security best practices for serverless deployments.
Sources:
cf.js
6-28
Request Routing Architecture
The worker implements a path-based routing system in the
handleRequest()
function. All incoming requests are inspected by URL pathname and dispatched to appropriate handler functions.
Route Table
Route Pattern
Method
Handler Function
Purpose
/MagicWordLatest.apk
GET
fetchRawFile()
Download latest APK (alias 1)
/latest/MagicWord.apk
GET
fetchRawFile()
Download latest APK (alias 2)
/notice.json
GET
fetchRawFile()
Fetch system announcements
/library/index.json
GET
fetchRawFile()
Fetch library index (legacy compatibility)
/library/file/*
GET
fetchRawFile()
Proxy any file from
magicwordfile
repository
/library/upload
POST
handleLibraryUpload()
Upload new library to data warehouse
/api/*
ALL
proxyRequest()
Proxy GitHub REST API requests (e.g., releases)
/*
(default)
GET
inline response
Return server status message
Sources:
cf.js
39-85
Core Functions
handleRequest()
Location:
cf.js
39-85
The main request handler registered with the
fetch
event listener. It performs URL parsing and route dispatching based on pathname matching.
Flow:
Parse request URL using
URL
constructor
Extract pathname from URL
Match pathname against route patterns (evaluated in order)
Invoke appropriate handler function
Return response (or default welcome message)
Error Handling:
Wrapped in a promise catch block at
cf.js
32-34
that returns a 500 response with error message.
fetchRawFile()
Location:
cf.js
95-121
Proxies files from GitHub Raw content CDN, adding cache-busting timestamps and CORS headers.
Parameters:
targetUrl
(string): Full URL to GitHub Raw resource
contentType
(string): MIME type for
Content-Type
header
contentDisposition
(string, optional): Value for
Content-Disposition
header
Implementation Details:
Key Features:
Cache Prevention
: Appends
?t=${Date.now()}
query parameter to bypass Cloudflare edge cache
cf.js
98
Header Injection
: Sets
Access-Control-Allow-Origin: *
for cross-origin requests
cf.js
112
Content-Type Override
: Replaces GitHub's content-type with specified value
cf.js
108
User-Agent
: Identifies as
MagicWord-Proxy-Worker
cf.js
102
Sources:
cf.js
95-121
handleLibraryUpload()
Location:
cf.js
126-176
Processes library upload requests from clients, creating both
info.json
and
library.json
files in the data warehouse.
Request Body Schema:
Processing Flow:
Parse JSON request body
cf.js
128
Validate required fields (
name
,
contentBase64
)
cf.js
131-133
Generate timestamp ID:
Date.now().toString()
cf.js
135
Construct
info.json
metadata object
cf.js
138-145
Base64-encode
info.json
using UTF-8 safe encoding
cf.js
148-150
Upload
info.json
via
uploadToGithub()
cf.js
152
Upload
library.json
(already base64-encoded)
cf.js
159
Return success response with library ID
cf.js
165-168
File Structure Created:
magicwordfile/
└── {timestamp}/
    ├── info.json       # Metadata (name, description, tags, author)
    └── library.json    # Word entries
Error Handling:
Catches exceptions and returns 500 response with error message in JSON format
cf.js
170-175
Sources:
cf.js
126-176
uploadToGithub()
Location:
cf.js
181-203
Commits a single file to the
magicwordfile
repository using GitHub Contents API.
Parameters:
path
(string): File path within repository (e.g.,
"1709823456789/info.json"
)
contentBase64
(string): Base64-encoded file content
API Endpoint:
PUT https://api.github.com/repos/{owner}/{repo}/contents/{path}
Request Headers:
Header
Value
Purpose
Authorization
Bearer ${GITHUB_TOKEN}
Authentication for write operations
User-Agent
MagicWord-Proxy-Worker
Client identification
Content-Type
application/json
Request body format
Accept
application/vnd.github.v3+json
API version specification
Request Body:
Token Validation:
Checks if
GITHUB_TOKEN
is properly configured before attempting upload
cf.js
186-188
Sources:
cf.js
181-203
proxyRequest()
Location:
cf.js
208-238
Generic proxy function for forwarding requests to GitHub API, used primarily for release checking and other API operations.
Implementation Strategy:
Header Transformations:
Outgoing (to GitHub):
Set
Host
to target domain
cf.js
210
Set
User-Agent
to
MagicWord-Proxy-Worker
cf.js
211
Remove Cloudflare-specific headers:
cf-connecting-ip
,
cf-ray
,
cf-visitor
cf.js
214
Remove sensitive headers:
Authorization
,
Cookie
cf.js
214
Incoming (from GitHub):
Add
Access-Control-Allow-Origin: *
cf.js
226
Remove
content-security-policy
and
x-frame-options
cf.js
229
Body Handling:
Only includes request body for non-GET/HEAD methods
cf.js
220
Sources:
cf.js
208-238
CORS and Network Accessibility
The primary motivation for the Cloudflare Worker is solving cross-origin resource sharing limitations when accessing GitHub resources from mobile and web clients.
CORS Problem
GitHub Raw content (
raw.githubusercontent.com
) does not set CORS headers, preventing browser-based and some mobile HTTP clients from fetching resources directly. Additionally, some regions experience network restrictions accessing GitHub domains.
Solution Architecture
The worker acts as a same-origin proxy:
Direct Access (Blocked)
Proxied Access (Allowed)
Android →
raw.githubusercontent.com
❌
Android →
mag.upxuu.com
→ GitHub ✅
CORS error (no
Access-Control-Allow-Origin
)
CORS headers added by worker
Subject to regional DNS/routing issues
Cloudflare edge routing
All responses from
fetchRawFile()
and
proxyRequest()
include:
Access-Control-Allow-Origin: *
This header is injected at
cf.js
112
cf.js
167
cf.js
173
and
cf.js
226
Sources:
cf.js
95-121
cf.js
208-238
README.md
86
Upload Gateway Implementation
The library upload system is a two-phase process that creates a timestamped directory structure in the data warehouse.
Upload Request Flow
Base64 Encoding Strategy
The worker uses a custom UTF-8 safe base64 encoding function for
info.json
:
This three-step process
cf.js
148-150
:
encodeURIComponent(str)
- Convert to percent-encoded UTF-8
unescape()
- Convert percent-encoding to byte string
btoa()
- Base64 encode byte string
The
library.json
content is already base64-encoded by the client, so it's passed through directly
cf.js
159
Metadata Structure
The
info.json
file created at
cf.js
138-145
follows this schema:
Sources:
cf.js
126-176
verify_online_api.py
27-80
Error Handling and Status Codes
The worker implements defensive error handling at multiple levels:
Top-Level Error Boundary
The fetch event listener wraps
handleRequest()
in a catch block:
This ensures any unhandled exception returns a 500 response
cf.js
32-34
Function-Level Error Handling
Function
Error Cases
Status Code
Response Format
fetchRawFile()
Network error
502
Proxy Error: {message}
fetchRawFile()
GitHub 404
404
File not found on GitHub Raw...
handleLibraryUpload()
Missing fields
400
{"error": "Missing name or content"}
handleLibraryUpload()
Upload failure
500
{"error": "{detailed message}"}
uploadToGithub()
Missing token
N/A
Returns object with
ok: false
proxyRequest()
Network error
502
Proxy Error: {message}
HTTP Status Code Usage
200
: Successful proxy or upload
400
: Client error (malformed upload request)
404
: Resource not found on GitHub
500
: Server-side error (upload failure, JSON parsing error)
502
: Network/proxy error (failed to reach GitHub)
Sources:
cf.js
32-34
cf.js
116-120
cf.js
131-133
cf.js
170-175
cf.js
236
Verification and Testing
The repository includes Python scripts for verifying worker functionality:
verify_proxy.py
Location:
verify_proxy.py
1-55
Tests basic proxy functionality:
APK Download Test
: Verifies
/MagicWordLatest.apk
route returns correct content-type and file headers
API Proxy Test
: Verifies
/api/repos/{owner}/{repo}/releases/latest
correctly proxies GitHub API
verify_online_api.py
Location:
verify_online_api.py
1-130
Comprehensive test suite for library operations:
Index Retrieval
: Tests
GET /library/index.json
Library Upload
: Tests
POST /library/upload
with dummy library data
Library Download
: Tests
GET /library/file/{timestamp}/library.json
Index Update
: Waits for GitHub Actions to regenerate indexes, then re-fetches
Upload Test Payload:
Sources:
verify_proxy.py
1-55
verify_online_api.py
1-130
Deployment Configuration
While detailed deployment instructions are covered in
Development & Deployment
, the worker requires specific configuration:
Environment Variables
Must be set in Cloudflare Worker settings:
Variable
Type
Purpose
GH_TOKEN
Secret
GitHub Personal Access Token with
repo
scope
Worker Script
The
cf.js
file is deployed as-is to Cloudflare Workers using the Wrangler CLI or Cloudflare dashboard.
Routing
The worker is bound to the domain
mag.upxuu.com
via Cloudflare Workers routes configuration.
Sources:
cf.js
22-24
README.md
202-208
Integration with Android Client
The Android application interacts with the worker through OkHttp-based network calls. Key integration points:
Base URL Configuration
The Android client configures its network layer to use
https://mag.upxuu.com
as the base URL for all library operations.
API Consumption Patterns
Feature
Worker Route
Android Component
Download library catalog
GET /library/file/index_{X}.json
LibraryViewModel.loadOnlineLibraries()
Download library content
GET /library/file/{timestamp}/library.json
LibraryViewModel.downloadLibrary()
Upload library
POST /library/upload
LibraryViewModel.uploadLibrary()
Check for updates
GET /api/repos/.../releases/latest
UpdateManager.checkForUpdate()
Download APK
GET /MagicWordLatest.apk
UpdateManager.downloadUpdate()
CORS Enablement
The worker's CORS headers enable the Android WebView components (if any) and facilitate testing from browser-based tools without requiring proxy configuration.
Sources:
README.md
80-94
cf.js
1-239
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Cloudflare Worker - API Gateway
Purpose and Scope
System Role and Responsibilities
Configuration Constants
Request Routing Architecture
Route Table
Core Functions
handleRequest()
fetchRawFile()
handleLibraryUpload()
uploadToGithub()
proxyRequest()
CORS and Network Accessibility
CORS Problem
Solution Architecture
Upload Gateway Implementation
Upload Request Flow
Base64 Encoding Strategy
Metadata Structure
Error Handling and Status Codes
Top-Level Error Boundary
Function-Level Error Handling
HTTP Status Code Usage
Verification and Testing
verify_proxy.py
verify_online_api.py
Deployment Configuration
Environment Variables
Worker Script
Routing
Integration with Android Client
Base URL Configuration
API Consumption Patterns
CORS Enablement

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/3.2-github-data-warehouse

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
GitHub Data Warehouse
Relevant source files
LICENSE
README.md
README_EN.md
app/src/main/java/com/magicword/app/data/ExportModels.kt
app/src/main/java/com/magicword/app/ui/LibraryManagerScreen.kt
cf.js
verify_online_api.py
verify_proxy.py
Purpose and Scope
This document describes the
magicwordfile
GitHub repository, which serves as the primary data warehouse for the MagicWord vocabulary sharing platform. It explains the repository structure, file formats, automated indexing system, and how the Android client and Cloudflare Worker interact with this storage layer.
For information about the Cloudflare Worker that proxies access to this warehouse, see
Cloudflare Worker - API Gateway
. For details on how the Android client consumes this data, see
LibraryManagerScreen - Library Operations
.
Repository Architecture
The
magicwordfile
repository (
lijiaxu2021/magicwordfile
) functions as a
git-based NoSQL database
where each vocabulary library is stored as a timestamped folder containing JSON files. GitHub Actions provide the "compute layer" by automatically generating searchable indexes whenever new data is pushed.
Repository Structure
magicwordfile/
├── .github/
│   └── workflows/
│       └── update_index.yml          # Auto-indexing workflow
├── index_0.json                      # Page 0 (most recent libraries)
├── index_1.json                      # Page 1 (older libraries)
├── index_N.json                      # Page N (pagination)
├── num.json                          # Metadata (total pages, items, timestamp)
├── tags.json                         # Tag frequency statistics
├── 1770900184827/                    # Library folder (timestamp ID)
│   ├── info.json                     # Library metadata
│   └── library.json                  # Word data
├── 1770900184828/
│   ├── info.json
│   └── library.json
└── ...
Sources:
README.md
102-113
cf.js
9-19
Library Storage Format
Timestamp-Based Folder Organization
Each uploaded library is stored in a folder named with its Unix timestamp (milliseconds). This provides:
Unique Identifiers
: Collision-free IDs for all libraries
Chronological Ordering
: Natural time-based sorting
URL Path Construction
: Direct mapping to download URLs
The Cloudflare Worker generates these timestamps during upload:
Sources:
cf.js
135
info.json Format
The
info.json
file contains library metadata used for indexing and display:
This structure is created by the Cloudflare Worker's
handleLibraryUpload
function:
Field Definitions:
Field
Type
Description
id
String
Timestamp identifier (same as folder name)
name
String
Display name for the library
description
String
User-provided description
tags
Array
Searchable tags for categorization
timestamp
Number
Creation time in milliseconds
author
String
Currently hardcoded as "User"
Sources:
cf.js
138-145
README.md
147-158
library.json Format
The
library.json
file contains the actual word data. It accepts two formats:
Format 1: Legacy List Format
(used by
importLibraryJson
)
Format 2: Export Package Format
(from
ExportPackage
model)
The Android client's
LibraryViewModel
handles both formats transparently via the
importLibraryJson
function.
Sources:
ExportModels.kt
4-19
verify_online_api.py
32-53
Index Generation System
Pagination System (index_X.json)
To support efficient loading of large library catalogs, the system generates paginated index files:
Index File Structure:
Each
index_X.json
contains an array of library metadata with download URLs:
Sources:
README.md
115-124
README.md
144-158
Metadata File (num.json)
The
num.json
file provides catalog-level metadata that allows clients to implement pagination:
Client Usage Pattern:
Sources:
README.md
132-141
LibraryManagerScreen.kt
202-205
Tag Aggregation (tags.json)
The GitHub Actions workflow scans all
info.json
files to generate tag frequency statistics:
The Android client uses this for the tag filter sidebar in
OnlineLibraryTab
:
Sources:
README.md
160-168
LibraryManagerScreen.kt
195-246
GitHub Actions Automation
Workflow Trigger and Execution
The
.github/workflows/update_index.yml
workflow automatically executes on every push to the
main
branch:
Workflow Sequence:
This automation ensures that:
Zero Manual Maintenance
: No manual index updates required
Eventual Consistency
: Indexes update within ~30 seconds of upload
Atomic Updates
: All index files generated in single commit
Sources:
README.md
115-124
cf.js
181-203
Data Access Patterns
Cloudflare Worker Proxy Routes
All client access to the data warehouse is proxied through the Cloudflare Worker:
Route Implementation:
The
fetchRawFile
function in the Cloudflare Worker handles proxying:
Route Pattern
Maps To
Handler
/library/index.json
index.json
(legacy)
fetchRawFile(URL_LIB_INDEX)
/library/file/*
magicwordfile/*
fetchRawFile(targetUrl)
Sources:
cf.js
53-66
cf.js
95-121
Client-Side Loading Strategy
The
LibraryViewModel
implements a lazy loading pattern:
Scroll-Triggered Loading:
The
OnlineLibraryTab
triggers loading when the user scrolls near the bottom:
Sources:
LibraryManagerScreen.kt
202-343
Upload and Storage Flow
Complete Upload Lifecycle
Upload Function Implementation
The Cloudflare Worker's
handleLibraryUpload
function orchestrates the upload:
Step 1: Parse Request Body
Step 2: Create info.json
Step 3: Upload via GitHub API
The
uploadToGithub
helper uses the GitHub Contents API with authentication:
Sources:
cf.js
126-176
cf.js
181-203
API Protocol Reference
Endpoint Summary Table
Endpoint
Method
Description
Response Format
/library/file/num.json
GET
Fetch catalog metadata
{totalPages, totalItems, pageSize, lastUpdated}
/library/file/index_{X}.json
GET
Fetch page X of library index
Array<OnlineLibrary>
/library/file/tags.json
GET
Fetch tag frequency list
Array<{name, count}>
/library/file/{timestamp}/library.json
GET
Download library data
Array<Word>
or
ExportPackage
/library/upload
POST
Upload new library
{success: boolean, id: string}
Data Model Mapping:
The
OnlineLibrary
Kotlin data class maps directly to index entries:
Sources:
ExportModels.kt
24-32
README.md
127-192
Cache and Consistency Considerations
GitHub Raw CDN Caching
GitHub Raw content is served through a CDN with caching behavior:
Cache Duration
: Approximately 5 minutes
Implication
: Newly uploaded libraries may not be immediately accessible via raw URLs
Mitigation
: The Cloudflare Worker appends timestamps to bypass cache:
However, this only works for requests through the Worker. The GitHub Actions workflow commits do not benefit from this.
Upload-to-Availability Timeline:
T+0s
: User uploads library via
/library/upload
T+1s
: GitHub API commits files (instantly visible via API)
T+10-30s
: GitHub Actions workflow completes, commits index files
T+30s-5min
: Raw CDN cache updates, files become downloadable
Sources:
cf.js
98
verify_online_api.py
89-106
Client-Side Consistency Handling
The Android client handles eventual consistency through:
Retry Logic
: Network calls include error handling
Loading States
:
isNetworkLoading
StateFlow prevents duplicate requests
Log Feedback
:
importLogs
StateFlow provides user feedback during delays
Sources:
LibraryManagerScreen.kt
71-87
LibraryManagerScreen.kt
294-306
Security and Access Control
Authentication
Read Access
: Public (no authentication required for GET requests)
Write Access
: Requires
GITHUB_TOKEN
configured in Cloudflare Worker
Token Scope
: Must have
contents:write
permission for
magicwordfile
repository
The Worker validates token presence before upload:
Sources:
cf.js
22-24
cf.js
186-188
Content Validation
Currently, the system has
minimal content validation
:
No size limits enforced
No content moderation
No duplicate detection at upload time
Future improvements could include a moderation queue via the Cloudflare Worker's admin backend.
Sources:
cf.js
126-176
README.md
86-89
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
GitHub Data Warehouse
Purpose and Scope
Repository Architecture
Repository Structure
Library Storage Format
Timestamp-Based Folder Organization
info.json Format
library.json Format
Index Generation System
Pagination System (index_X.json)
Metadata File (num.json)
Tag Aggregation (tags.json)
GitHub Actions Automation
Workflow Trigger and Execution
Data Access Patterns
Cloudflare Worker Proxy Routes
Client-Side Loading Strategy
Upload and Storage Flow
Complete Upload Lifecycle
Upload Function Implementation
API Protocol Reference
Endpoint Summary Table
Cache and Consistency Considerations
GitHub Raw CDN Caching
Client-Side Consistency Handling
Security and Access Control
Authentication
Content Validation

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/3.3-update-and-notice-distribution

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Update & Notice Distribution
Relevant source files
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
cf.js
notice.json
verify_notice.py
verify_online_api.py
verify_proxy.py
This document describes the system for distributing application updates and system notices to MagicWord users. The infrastructure uses GitHub Releases for version management, GitHub repository files for notice delivery, and a Cloudflare Worker proxy to ensure accessibility and bypass potential network restrictions. The system enables self-updating capabilities that bypass traditional app stores, which is critical for users in regions with limited app store access.
For information about the Cloudflare Worker's broader functionality, see
Cloudflare Worker - API Gateway
. For details on library file distribution, see
GitHub Data Warehouse
.
System Architecture Overview
The update and notice distribution system operates through a three-component architecture: a notice file and APK hosted on GitHub, a Cloudflare Worker proxy layer, and the Android client's
UpdateManager
.
Sources:
cf.js
1-239
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
1-170
Notice System
Notice File Structure
The
notice.json
file provides system-wide announcements and critical metadata displayed to users on app launch. It follows a simple JSON schema:
Field
Type
Description
title
String
Notice title (supports Chinese/English)
content
String
Notice content or version identifier
versionCode
Integer
Target version code for notice relevance
timestamp
Long
Unix timestamp (milliseconds) for notice creation
Example:
Sources:
notice.json
1-6
Notice Distribution Flow
The Cloudflare Worker proxies
notice.json
from GitHub's raw content API at
cf.js
49-51
It appends a timestamp query parameter to bypass edge caching
cf.js
98
and sets appropriate CORS headers
cf.js
112
to enable client-side access.
Sources:
cf.js
17-18
cf.js
49-51
cf.js
95-121
Update System
Version Checking Mechanism
The
UpdateManager
checks for new versions by querying the GitHub Releases API through the Cloudflare Worker proxy. This design avoids direct GitHub API calls that may fail in restricted network environments.
Update Flow:
Key Implementation Details:
Component
Implementation
Location
API Endpoint
$PROXY_BASE_URL/api/repos/$GITHUB_OWNER/$GITHUB_REPO/releases/latest
UpdateManager.kt
22
HTTP Client
OkHttpClient
with 15s connect, 30s read timeout
UpdateManager.kt
24-27
Response Model
ReleaseResponse
data class with
tag_name
,
body
,
assets
UpdateManager.kt
159-163
Version Parsing
Removes "v" prefix from tag (e.g., "v1.2.3" → "1.2.3")
UpdateManager.kt
47
APK URL
Always uses
$PROXY_BASE_URL/MagicWordLatest.apk
for direct download
UpdateManager.kt
54
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
16-68
Version Comparison Algorithm
The
compareVersions()
function implements semantic versioning comparison:
The algorithm splits version strings by ".", converts each part to an integer (defaulting to 0 for non-numeric parts), and compares each segment sequentially
UpdateManager.kt
70-81
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
70-81
APK Download Process
The download mechanism provides progress tracking and handles large file transfers efficiently:
Implementation Highlights:
Buffer Size:
8KB chunks for memory efficiency
UpdateManager.kt
98
Progress Callback:
Calculates percentage based on
contentLength()
UpdateManager.kt
106
Coroutine Context:
Runs on
Dispatchers.IO
for background execution
UpdateManager.kt
84
Error Handling:
Returns boolean success status with exception printing
UpdateManager.kt
114-115
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
83-118
Installation Flow (Android 8.0+)
The
installApk()
function handles the complexity of Android package installation permissions:
Permission Handling Details:
API Level
Permission Requirement
Implementation
< 26 (Pre-Oreo)
None
Direct install via
FileProvider
>= 26 (Oreo+)
REQUEST_INSTALL_PACKAGES
runtime permission
Check
canRequestPackageInstalls()
→ redirect to Settings if false
The function uses a
FileProvider
with authority
${BuildConfig.APPLICATION_ID}.provider
UpdateManager.kt
142-145
to expose the APK file securely through a
content://
URI, which is required on Android 7.0+ (API 24) for inter-app file sharing.
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
120-157
Cloudflare Worker Routing
The Cloudflare Worker exposes two primary routes for the update/notice system:
Route Configuration
Route Implementation:
Route Pattern
Handler
Target
Headers Set
/notice.json
fetchRawFile()
${RAW_BASE}/${GH_USERNAME}/${GH_REPO_APP}/${GH_BRANCH}/notice.json
Content-Type:
application/json
/MagicWordLatest.apk
fetchRawFile()
${RAW_BASE}/${GH_USERNAME}/${GH_REPO_APP}/${GH_BRANCH}/MagicWordLatest.apk
Content-Type:
application/vnd.android.package-archive
Content-Disposition:
attachment; filename="MagicWordLatest.apk"
/api/*
proxyRequest()
https://api.github.com${newPath}
Host:
api.github.com
User-Agent:
MagicWord-Proxy-Worker
Sources:
cf.js
39-85
fetchRawFile() Implementation
The
fetchRawFile()
function
cf.js
95-121
handles the core proxy logic:
Cache Busting:
Appends
?t=${Date.now()}
timestamp to prevent Cloudflare edge caching
cf.js
98
User Agent:
Sets
MagicWord-Proxy-Worker
to identify proxy traffic
cf.js
102
CORS Headers:
Adds
Access-Control-Allow-Origin: *
to enable cross-origin requests
cf.js
112
Custom Headers:
Applies
Content-Type
and
Content-Disposition
for proper file handling
cf.js
108-109
Error Handling:
Returns 404 for missing files, 502 for proxy errors
cf.js
116-119
Sources:
cf.js
95-121
Data Flow Summary
Complete Update Check Flow
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
36-68
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
83-118
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
120-157
cf.js
39-85
Configuration and Constants
UpdateManager Configuration
The
UpdateManager
object
UpdateManager.kt
16
defines critical constants:
Sources:
app/src/main/java/com/magicword/app/utils/UpdateManager.kt
17-22
Cloudflare Worker Configuration
The worker script
cf.js
8-19
defines repository and URL constants:
Sources:
cf.js
8-19
Testing and Verification
The repository includes Python scripts for verifying the update and notice distribution system:
verify_proxy.py
Tests both APK download and API proxy functionality:
APK Download Test:
Streams first 100 bytes to verify response
verify_proxy.py
8-26
API Proxy Test:
Fetches latest release metadata and verifies APK asset presence
verify_proxy.py
28-49
verify_notice.py
Validates notice delivery:
Notice Fetch:
Retrieves and displays
notice.json
content
verify_notice.py
7-18
APK Header Check:
Uses HEAD request to verify APK availability without downloading
verify_notice.py
20-29
Sources:
verify_proxy.py
1-55
verify_notice.py
1-35
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Update & Notice Distribution
System Architecture Overview
Notice System
Notice File Structure
Notice Distribution Flow
Update System
Version Checking Mechanism
Version Comparison Algorithm
APK Download Process
Installation Flow (Android 8.0+)
Cloudflare Worker Routing
Route Configuration
fetchRawFile() Implementation
Data Flow Summary
Complete Update Check Flow
Configuration and Constants
UpdateManager Configuration
Cloudflare Worker Configuration
Testing and Verification
verify_proxy.py
verify_notice.py

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/4-development-and-deployment

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Development & Deployment
Relevant source files
.github/workflows/android.yml
app/build.gradle.kts
app/src/main/res/values/strings.xml
settings.gradle.kts
Purpose and Scope
This document provides an overview of the MagicWord development workflow, build system, and deployment infrastructure. It covers the local development environment setup, Gradle build configuration, CI/CD automation, and the release process for distributing APK files to users.
For detailed information about CI/CD workflows and automation, see
CI/CD Pipeline
. For step-by-step release procedures and version management, see
Release Process
.
Development Environment
MagicWord is built as a native Android application using Kotlin and Jetpack Compose. The development environment requires:
Requirement
Version/Details
JDK
17 (Temurin distribution)
Gradle
Managed via wrapper
Android SDK
compileSdk 34, targetSdk 34, minSdk 24
Kotlin
1.9.x with Compose 1.5.4
Build Tools
KSP (Kotlin Symbol Processing)
The project uses the standard Android application structure with Gradle Kotlin DSL for build configuration. The root project is named
MagicWord
with a single application module
app
.
Sources:
settings.gradle.kts
1-18
app/build.gradle.kts
8-10
Build System Architecture
The build system is configured through
app/build.gradle.kts
and uses the Android Gradle Plugin with Kotlin support. The configuration implements a dual build type system with signing for production releases.
Build Configuration Overview
Sources:
app/build.gradle.kts
1-69
settings.gradle.kts
1-18
Application Versioning
Version information is managed in
app/build.gradle.kts
through two key properties:
versionCode
- Integer incremented for each release (currently 22)
versionName
- Semantic version string displayed to users (currently "0.0.21")
The
versionCode
must be incremented for each release to satisfy Android's update requirements. The
versionName
follows semantic versioning and is extracted by CI/CD scripts for artifact naming.
Sources:
app/build.gradle.kts
12-23
Signing Configuration
The release build type uses a dedicated signing configuration that supports both local and CI/CD environments through environment variable fallbacks:
Environment Variable
Purpose
Default Fallback
KEYSTORE_PATH
Path to keystore file
release.jks
STORE_PASSWORD
Keystore password
password
KEY_ALIAS
Signing key alias
alias
KEY_PASSWORD
Key password
password
This design allows local developers to use a local keystore while CI/CD uses secrets injected as environment variables.
Sources:
app/build.gradle.kts
25-49
Dependency Management
The build configuration declares dependencies across several categories:
Category
Key Dependencies
Version
Core Android
core-ktx
,
lifecycle-runtime-ktx
,
activity-compose
1.x/2.x
Compose UI
compose-bom
,
material3
,
material-icons-extended
BOM 2023.08.00
Navigation
navigation-compose
2.7.5
Database
room-runtime
,
room-ktx
,
room-compiler
(KSP)
2.6.1
Network
retrofit
,
converter-gson
2.9.0
Background Work
work-runtime-ktx
2.9.0
UI Components
reorderable
(for drag-and-drop)
2.4.3
The Room compiler uses KSP (Kotlin Symbol Processing) for code generation, which is faster than KAPT.
Sources:
app/build.gradle.kts
71-107
CI/CD Pipeline Overview
The project uses GitHub Actions for automated builds, testing, and releases. The pipeline is triggered on pushes to
feature/native-android
and
main
branches, as well as pull requests to
main
.
Pipeline Architecture
Sources:
.github/workflows/android.yml
1-90
Build Job Steps
The workflow executes the following steps in sequence:
Environment Setup
- Checkout code, install JDK 17, enable Gradle wrapper execution
Keystore Decoding
- Base64 decode
KEYSTORE_BASE64
secret to
app/release.jks
Build Execution
- Run
./gradlew assembleRelease
with signing environment variables
Version Extraction
- Parse
versionName
from
app/build.gradle.kts
using
grep
and
awk
Artifact Upload
- Upload
app-release.apk
to GitHub Actions artifacts
APK Renaming
- Create three copies:
app-release.apk
,
MagicWord-vX.X.X.apk
,
MagicWord.apk
Release Creation
(main branch only) - Create GitHub Release with versioned and unversioned APKs
Repository Update
(main branch only) - Commit
MagicWordLatest.apk
to main branch with
[skip ci]
flag
Sources:
.github/workflows/android.yml
16-90
Conditional Release Logic
The workflow includes conditional steps that execute only on pushes to the
main
branch:
This ensures that releases and repository updates occur only for production builds, not for feature branch pushes or pull request validation.
Sources:
.github/workflows/android.yml
61-89
Release Distribution Mechanisms
MagicWord employs a three-tier distribution system to ensure APK availability through multiple channels:
Distribution Channel
Artifact Name
Purpose
GitHub Actions Artifacts
MagicWord-vX.X.X
Build history and manual download
GitHub Releases
MagicWord-vX.X.X.apk
,
MagicWord.apk
Version-specific and stable channel
Repository File
MagicWordLatest.apk
(main branch)
Cloudflare Worker proxy endpoint
Distribution Flow
Sources:
.github/workflows/android.yml
49-89
Cloudflare Worker Integration
The
MagicWordLatest.apk
file in the repository is accessed via the Cloudflare Worker (documented in
Cloudflare Worker - API Gateway
), which proxies requests to the raw GitHub content. This solves CORS restrictions and provides a stable update endpoint that the Android app's
UpdateManager
can query without GitHub API rate limits.
The dual APK approach in GitHub Releases (
MagicWord-vX.X.X.apk
and
MagicWord.apk
) allows users to either download a specific version or always get the latest release through a stable filename.
Sources:
.github/workflows/android.yml
66-89
Version Management Strategy
The version management system uses a two-component approach:
Version Code Incrementing
The
versionCode
in
defaultConfig
must be manually incremented before each release. This integer value is used by Android to determine app update eligibility:
Failure to increment
versionCode
will prevent users from updating to the new version.
Sources:
app/build.gradle.kts
16
Version Name Extraction
The CI/CD pipeline extracts the
versionName
dynamically during the build process:
This extracted version is used for:
GitHub Actions artifact naming:
MagicWord-v{VERSION_NAME}
GitHub Release tag:
v{VERSION_NAME}
GitHub Release title:
Release v{VERSION_NAME}
APK filename:
MagicWord-v{VERSION_NAME}.apk
Sources:
.github/workflows/android.yml
43-47
Local Development Workflow
For local development without CI/CD:
Keystore Setup
- Place
release.jks
in the
app/
directory or configure environment variables
Version Update
- Increment
versionCode
and update
versionName
in
app/build.gradle.kts
Build APK
- Run
./gradlew assembleRelease
from project root
Locate APK
- Find output at
app/build/outputs/apk/release/app-release.apk
Manual Distribution
- Distribute APK through desired channels
For development builds without signing requirements, use the
debug
build type:
This produces
app-debug.apk
without signing configuration.
Sources:
app/build.gradle.kts
37-49
Build System Plugins
The project uses five Gradle plugins for build functionality:
Plugin ID
Purpose
com.android.application
Android app build support
org.jetbrains.kotlin.android
Kotlin language support for Android
com.google.devtools.ksp
Kotlin Symbol Processing (Room compiler)
kotlin-parcelize
Parcelable implementation generation
The
buildFeatures
configuration enables:
compose = true
- Jetpack Compose UI toolkit
buildConfig = true
- BuildConfig class generation for version access
Sources:
app/build.gradle.kts
1-69
Repository Structure for Builds
Sources:
app/build.gradle.kts
1-108
.github/workflows/android.yml
1-90
settings.gradle.kts
1-18
Next Steps
For detailed information about:
CI/CD workflow configuration, secrets management, and automation logic, see
CI/CD Pipeline
Release creation procedures, versioning conventions, and distribution best practices, see
Release Process
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Development & Deployment
Purpose and Scope
Development Environment
Build System Architecture
Build Configuration Overview
Application Versioning
Signing Configuration
Dependency Management
CI/CD Pipeline Overview
Pipeline Architecture
Build Job Steps
Conditional Release Logic
Release Distribution Mechanisms
Distribution Flow
Cloudflare Worker Integration
Version Management Strategy
Version Code Incrementing
Version Name Extraction
Local Development Workflow
Build System Plugins
Repository Structure for Builds
Next Steps

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/4.1-cicd-pipeline

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
CI/CD Pipeline
Relevant source files
.github/workflows/android.yml
app/src/main/res/values/strings.xml
settings.gradle.kts
Purpose and Scope
This document describes the GitHub Actions-based CI/CD pipeline that automates the build, signing, and distribution of the MagicWord Android application. The pipeline handles continuous integration on feature branches, automated release creation on the main branch, and deployment of APK files to both GitHub Releases and the repository itself for the update system.
For information about the Gradle build configuration that the pipeline executes, see
Build Configuration
. For details on the manual release process and version management, see
Release Process
. For how the deployed artifacts are consumed by the app's self-update mechanism, see
Update System
.
Pipeline Overview
The CI/CD pipeline is implemented as a single GitHub Actions workflow named "Android Build" that orchestrates the entire build-to-deployment process. The workflow executes different deployment steps based on the branch being built, enabling both continuous integration testing and automated production releases.
Workflow Architecture
Sources:
.github/workflows/android.yml
1-90
Workflow Triggers
The pipeline responds to three types of GitHub events, each serving different purposes in the development workflow.
Trigger Type
Branches
Purpose
Deployment Actions
push
feature/native-android
,
main
Build and validate changes
Artifacts only (feature), Full deployment (main)
pull_request
main
Pre-merge validation
Artifacts only
The conditional deployment logic ensures that only commits merged to the
main
branch trigger production releases and repository updates:
This condition is applied to both the "Create Release" and "Push APK to Repo" steps.
Sources:
.github/workflows/android.yml
3-7
.github/workflows/android.yml
61
.github/workflows/android.yml
75
Build Environment Setup
The pipeline establishes a consistent build environment using GitHub's
ubuntu-latest
runner with specific Java and caching configurations.
JDK Configuration
The workflow uses the Eclipse Temurin distribution of JDK 17 and enables Gradle's dependency caching to optimize subsequent builds. The cache key is automatically generated by the
actions/setup-java
action based on Gradle wrapper properties and dependency declarations.
Sources:
.github/workflows/android.yml
14
.github/workflows/android.yml
19-24
.github/workflows/android.yml
26-27
Secrets Management and Keystore Decoding
The pipeline securely handles APK signing credentials through GitHub Secrets, avoiding the need to commit sensitive keystore files to the repository.
Keystore Reconstruction Process
The keystore decoding step reconstructs the signing certificate from a base64-encoded secret:
The Gradle build then consumes the keystore and credentials through environment variables that match the signing configuration in
app/build.gradle.kts
(documented in
Build Configuration
).
Required GitHub Secrets:
Secret Name
Purpose
Format
KEYSTORE_BASE64
Base64-encoded keystore file
Base64 string
KEY_ALIAS
Key alias in the keystore
String
KEY_PASSWORD
Password for the key
String
STORE_PASSWORD
Password for the keystore
String
Sources:
.github/workflows/android.yml
29-34
.github/workflows/android.yml
35-41
Build Execution
The pipeline executes the Gradle build with the
assembleRelease
task, which compiles the source code, processes resources, and produces a signed release APK.
The build process:
Resolves dependencies (cached by
actions/setup-java
)
Compiles Kotlin source files
Processes Android resources and manifests
Signs the APK using the decoded keystore
Outputs the APK to
app/build/outputs/apk/release/app-release.apk
The signing configuration is defined in the Gradle build files and uses the environment variables set in the previous step.
Sources:
.github/workflows/android.yml
41
Version Extraction
The pipeline dynamically extracts the version number from the Gradle build configuration to ensure consistent naming across artifacts and releases.
Version Extraction Mechanism
The extraction command parses the Gradle configuration file:
This extracted version is stored as a step output (
steps.get_version.outputs.VERSION_NAME
) and used in subsequent steps for naming artifacts and releases.
Sources:
.github/workflows/android.yml
43-47
Artifact Generation and Distribution
The pipeline generates multiple APK artifacts with different naming conventions to serve different distribution channels.
Artifact Naming Strategy
APK Variants:
File Name
Purpose
Distribution Channel
MagicWord-vX.Y.Z.apk
Version-tagged release archive
GitHub Releases
MagicWord.apk
Generic download name
GitHub Releases
MagicWordLatest.apk
Stable URL for updates
Repository root (served via Cloudflare)
MagicWord-vX.Y.Z.zip
(artifact)
CI/CD build artifact
GitHub Actions Artifacts
The renaming process creates the versioned and generic variants:
Sources:
.github/workflows/android.yml
49-58
GitHub Release Automation
When changes are pushed to the
main
branch, the pipeline automatically creates a GitHub Release with the versioned APK files attached.
Release Creation Configuration
The
softprops/action-gh-release@v1
action creates a release with the following properties:
Property
Value
Purpose
tag_name
v$VERSION_NAME
Git tag for the release
name
Release v$VERSION_NAME
Display name in GitHub UI
files
MagicWord-vX.Y.Z.apk
,
MagicWord.apk
Attached binary assets
draft
false
Immediately visible to users
prerelease
false
Marked as stable release
The action uses the
GITHUB_TOKEN
secret automatically provided by GitHub Actions with
contents: write
permission.
Sources:
.github/workflows/android.yml
60-72
.github/workflows/android.yml
9-10
Repository Deployment
The final deployment step commits the APK to the repository root as
MagicWordLatest.apk
, creating a stable URL that the Cloudflare Worker proxies for the update system.
Repository Push Process
The deployment script includes collision prevention and retry logic:
Key Features:
Skip CI tag:
The commit message includes
[skip ci]
to prevent triggering another build cycle
Rebase strategy:
Uses
--rebase
to maintain a linear history
Conditional commit:
Fails gracefully if there are no changes to commit
Retry mechanism:
If the push fails (e.g., due to concurrent commits), it pulls again and retries
Sources:
.github/workflows/android.yml
74-89
Integration with Update System
The
MagicWordLatest.apk
file committed to the repository root is the critical link in the application's self-update mechanism.
Update Distribution Flow
The Cloudflare Worker proxies requests to the raw GitHub content URL, solving CORS and network restriction issues. The stable file name (
MagicWordLatest.apk
) ensures that the update URL never changes, simplifying the update logic in the Android app.
For details on how the
UpdateManager
checks for updates and downloads this file, see
Update System
. For information on the Cloudflare Worker's routing logic, see
Cloudflare Worker - API Gateway
.
Sources:
.github/workflows/android.yml
85-89
Pipeline Permissions
The workflow requires specific permissions to perform its deployment operations:
The
contents: write
permission allows the workflow to:
Create and push commits to the repository (for
MagicWordLatest.apk
)
Create tags
Create releases
Upload release assets
This permission is automatically granted to the
GITHUB_TOKEN
secret when specified in the workflow configuration.
Sources:
.github/workflows/android.yml
9-10
Build Optimization
The pipeline includes several optimizations to reduce build times and resource usage:
Optimization
Mechanism
Benefit
Gradle Caching
actions/setup-java
cache parameter
Avoids re-downloading dependencies across builds
Gradle Wrapper
Committed
gradlew
script
Ensures consistent Gradle version
Artifact Compression
actions/upload-artifact
automatic compression
Reduces storage and download time
Conditional Deployment
Branch-based
if
conditions
Prevents unnecessary release operations on feature branches
The Gradle cache is keyed by a hash of the Gradle wrapper properties and build files, ensuring cache invalidation when dependencies change.
Sources:
.github/workflows/android.yml
24
.github/workflows/android.yml
61
.github/workflows/android.yml
75
Troubleshooting and Maintenance
Common Build Failures
Issue
Symptom
Solution
Missing secrets
Error: Input required
Verify all four keystore secrets are set in repository settings
Version extraction fails
Empty
VERSION_NAME
Ensure
versionName
is defined in
app/build.gradle.kts
Push conflict
git push
fails
The retry logic should handle this; check for manual commits during CI
APK signing fails
Unsigned APK in output
Verify keystore password secrets are correct
Monitoring Pipeline Health
GitHub Actions provides built-in monitoring for workflow runs:
Workflow runs:
Track success/failure rate in the Actions tab
Build duration:
Monitor average build time to detect performance degradation
Artifact size:
Track APK size growth over time
Manual Intervention
If the automated release fails or needs to be recreated:
Delete the failed tag and release from GitHub
Re-run the workflow from the Actions tab
If
MagicWordLatest.apk
is corrupted, manually revert the commit and re-trigger the build
For details on manual release procedures, see
Release Process
.
Sources:
.github/workflows/android.yml
1-90
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
CI/CD Pipeline
Purpose and Scope
Pipeline Overview
Workflow Triggers
Build Environment Setup
JDK Configuration
Secrets Management and Keystore Decoding
Keystore Reconstruction Process
Build Execution
Version Extraction
Version Extraction Mechanism
Artifact Generation and Distribution
Artifact Naming Strategy
GitHub Release Automation
Release Creation Configuration
Repository Deployment
Repository Push Process
Integration with Update System
Update Distribution Flow
Pipeline Permissions
Build Optimization
Troubleshooting and Maintenance
Common Build Failures
Monitoring Pipeline Health
Manual Intervention

==================================================


# Source: https://deepwiki.com/lijiaxu2021/MagicWord/4.2-release-process

Loading...
Index your code with Devin
DeepWiki
DeepWiki
lijiaxu2021/MagicWord
Index your code with
Devin
Edit Wiki
Share
Loading...
Last indexed:
14 February 2026
(
0c4eb3
)
MagicWord Overview
System Architecture
Getting Started
Android Application
Core Components
LibraryViewModel - Central State Manager
Data Layer & Persistence
Build Configuration
User Interface Screens
MainScreen & Navigation
WordsScreen - Vocabulary Management
StudyScreen - Spaced Repetition Review
TestScreen - Quiz Functionality
LibraryManagerScreen - Library Operations
SettingsScreen & Configuration
Feature Systems
AI Integration
Spaced Repetition System (SM-2)
Update System
Cloud Infrastructure
Cloudflare Worker - API Gateway
GitHub Data Warehouse
Update & Notice Distribution
Development & Deployment
CI/CD Pipeline
Release Process
Menu
Release Process
Relevant source files
.github/workflows/android.yml
MagicWordLatest.apk
app/build.gradle.kts
app/src/main/res/values/strings.xml
settings.gradle.kts
This document describes the step-by-step process for creating and distributing releases of the MagicWord Android application. It covers version management, build automation via GitHub Actions, APK signing, artifact generation, and distribution through GitHub Releases.
For information about the CI/CD pipeline implementation details, see
CI/CD Pipeline
. For details about the update system that consumes these releases, see
Update System
.
Overview
The MagicWord release process is fully automated through GitHub Actions. When code is pushed to the
main
branch, the CI/CD pipeline automatically:
Builds a signed release APK
Creates versioned GitHub releases
Uploads multiple APK variants for distribution
Commits the latest APK back to the repository
This automation enables the application's self-update mechanism and provides users behind network restrictions an alternative distribution channel to traditional app stores.
Sources:
.github/workflows/android.yml
1-90
Version Management
Version Configuration
Version information is managed in the Gradle build configuration using two key properties:
versionCode
: An integer that must be incremented with each release (currently 22)
versionName
: A semantic version string displayed to users (currently "0.0.21")
Version Increment Rules:
Change Type
versionCode
versionName Example
Major feature
+1
1.0.0 → 2.0.0
Minor feature
+1
0.1.0 → 0.2.0
Bug fix
+1
0.0.21 → 0.0.22
Sources:
app/build.gradle.kts
16-17
Version Extraction
The GitHub Actions workflow automatically extracts the version name using a shell script:
This extracted version is then used for:
APK file naming
GitHub release tag creation (
v0.0.21
)
Artifact upload naming
Sources:
.github/workflows/android.yml
43-47
Build Configuration and Signing
Signing Configuration
Release APKs must be signed with a keystore for Android installation. The signing configuration uses environment variables to support both CI and local builds:
The signing configuration in
build.gradle.kts
provides fallback values for local development:
Property
Environment Variable
Fallback Default
storeFile
KEYSTORE_PATH
"release.jks"
storePassword
STORE_PASSWORD
"password"
keyAlias
KEY_ALIAS
"alias"
keyPassword
KEY_PASSWORD
"password"
Sources:
app/build.gradle.kts
25-34
app/build.gradle.kts
37-45
.github/workflows/android.yml
29-33
.github/workflows/android.yml
36-41
Build Type Configuration
The release build type is configured with:
Signing
: Uses the
release
signing config
Minification
: Disabled (
isMinifyEnabled = false
)
ProGuard
: Configuration files specified but not actively used
Sources:
app/build.gradle.kts
37-45
Automated Release Workflow
Complete CI/CD Pipeline
The GitHub Actions workflow orchestrates the entire release process:
Sources:
.github/workflows/android.yml
1-90
Workflow Triggers
The workflow executes on:
Push events
to
main
or
feature/native-android
branches
Pull requests
targeting
main
branch
Release artifacts are only created and published when pushing to the
main
branch.
Sources:
.github/workflows/android.yml
3-7
Required Secrets
The following GitHub repository secrets must be configured:
Secret Name
Purpose
Used In
KEYSTORE_BASE64
Base64-encoded release keystore file
Keystore decoding
KEY_ALIAS
Keystore key alias
APK signing
KEY_PASSWORD
Key password
APK signing
STORE_PASSWORD
Keystore password
APK signing
GITHUB_TOKEN
GitHub API authentication
Release creation (auto-provided)
Sources:
.github/workflows/android.yml
29-40
.github/workflows/android.yml
71-72
APK Naming and Distribution
Artifact Generation
The build process generates multiple APK variants with different naming conventions:
Naming Convention Rationale
Filename
Purpose
Location
app-release.apk
Gradle build output (transient)
app/build/outputs/apk/release/
MagicWord-v0.0.21.apk
Version-specific release archive
GitHub Release assets
MagicWord.apk
Generic release name (duplicate)
GitHub Release assets
MagicWordLatest.apk
Update system source of truth
Repository root
The
MagicWordLatest.apk
file in the repository root serves as the canonical update source, proxied through the Cloudflare Worker at
/MagicWordLatest.apk
.
Sources:
.github/workflows/android.yml
55-68
.github/workflows/android.yml
85
GitHub Release Creation
Release Metadata
GitHub releases are created with the following structure:
Release Properties:
Tag
:
v{versionName}
(e.g.,
v0.0.21
)
Title
:
Release v{versionName}
Draft
:
false
(published immediately)
Pre-release
:
false
(marked as stable)
Assets
: Two APK files attached
Sources:
.github/workflows/android.yml
60-72
Conditional Execution
Release creation and repository updates only occur when:
The event is a push (not a pull request)
The target branch is
main
This is enforced by the condition:
if: github.event_name == 'push' && github.ref == 'refs/heads/main'
Sources:
.github/workflows/android.yml
61
.github/workflows/android.yml
75
Repository APK Update
Commit Process
After creating the GitHub release, the workflow commits the latest APK back to the repository:
Key Implementation Details:
Skip CI Tag
: The commit message includes
[skip ci]
to prevent an infinite loop of builds
Rebase Strategy
: Uses
--rebase
to maintain a linear commit history
Retry Logic
: If the initial push fails (due to concurrent updates), it rebases and retries
Cleanup
: Runs
git checkout .
to discard any modified tracked files from the build process
Sources:
.github/workflows/android.yml
74-89
Manual Release Checklist
For developers creating a release, follow these steps:
1. Update Version Numbers
Edit
app/build.gradle.kts
16-17
:
2. Test Build Locally (Optional)
3. Commit and Push
4. Monitor GitHub Actions
Navigate to the
Actions
tab on GitHub and verify:
✅ Build succeeds
✅ Artifacts uploaded
✅ Release created
✅ APK committed to repository
5. Verify Distribution
Check the following URLs after the workflow completes:
GitHub Release
:
https://github.com/lijiaxu2021/MagicWord/releases/tag/v0.0.22
Repository APK
:
https://github.com/lijiaxu2021/MagicWord/blob/main/MagicWordLatest.apk
Cloudflare Proxy
:
https://mag.upxuu.com/MagicWordLatest.apk
(requires Cloudflare Worker)
Sources:
.github/workflows/android.yml
1-90
app/build.gradle.kts
16-17
Version History and Tracking
Current Version
As of the latest commit:
Version Code
: 22
Version Name
: "0.0.21"
Version Compatibility
The
minSdk
and
targetSdk
settings affect device compatibility:
Property
Value
Implication
minSdk
24
Supports Android 7.0 (Nougat) and above
targetSdk
34
Optimized for Android 14
compileSdk
34
Built against Android 14 SDK
Sources:
app/build.gradle.kts
10-17
Troubleshooting
Build Fails with Signing Errors
Symptom
: Error message about missing keystore or invalid credentials
Solution
:
Verify GitHub secrets are correctly configured
Check that
KEYSTORE_BASE64
is a valid base64 encoding of the keystore file
Ensure
KEY_ALIAS
matches the alias in the keystore
Release Not Created
Symptom
: Workflow completes but no GitHub release appears
Solution
:
Verify push was to
main
branch, not a feature branch
Check that
GITHUB_TOKEN
has
contents: write
permission
Ensure no release with the same tag already exists
Sources:
.github/workflows/android.yml
9-10
.github/workflows/android.yml
61
APK Not Committed to Repository
Symptom
:
MagicWordLatest.apk
not updated in repository
Solution
:
Check if commit message included changes: look for "No changes to commit" in logs
Verify push step succeeded (check for rebase conflicts)
Ensure branch protection rules allow GitHub Actions to push
Sources:
.github/workflows/android.yml
87
Version Extraction Fails
Symptom
: Error in "Get Release Version" step
Solution
:
Verify
versionName
is correctly formatted in
build.gradle.kts
Ensure line format is exactly:
versionName = "X.X.X"
Check that the file uses UTF-8 encoding
Sources:
.github/workflows/android.yml
43-47
Integration with Update System
The release process directly supports the in-app update mechanism:
UpdateManager
checks for new versions by comparing local
BuildConfig.VERSION_NAME
with remote version
The remote version is fetched from the GitHub Releases API via Cloudflare Worker proxy
If an update is available,
UpdateManager
downloads
MagicWordLatest.apk
from the Cloudflare Worker
The downloaded APK is installed using
FileProvider
and
PackageInstaller
This self-update capability is critical for users in regions where Google Play Store access is restricted.
Sources:
.github/workflows/android.yml
85
Summary
The MagicWord release process is a fully automated, Git-based workflow that:
Uses semantic versioning managed in
build.gradle.kts
Builds and signs APKs via GitHub Actions
Creates tagged GitHub releases with multiple APK variants
Maintains
MagicWordLatest.apk
in the repository for the update system
Requires minimal manual intervention (just version bumps and pushes to
main
)
This approach provides reliable, reproducible releases while supporting the application's self-update functionality.
Dismiss
Refresh this wiki
This wiki was recently refreshed. Please wait
7
day
s
to refresh again.
On this page
Release Process
Overview
Version Management
Version Configuration
Version Extraction
Build Configuration and Signing
Signing Configuration
Build Type Configuration
Automated Release Workflow
Complete CI/CD Pipeline
Workflow Triggers
Required Secrets
APK Naming and Distribution
Artifact Generation
Naming Convention Rationale
GitHub Release Creation
Release Metadata
Conditional Execution
Repository APK Update
Commit Process
Manual Release Checklist
1. Update Version Numbers
2. Test Build Locally (Optional)
3. Commit and Push
4. Monitor GitHub Actions
5. Verify Distribution
Version History and Tracking
Current Version
Version Compatibility
Troubleshooting
Build Fails with Signing Errors
Release Not Created
APK Not Committed to Repository
Version Extraction Fails
Integration with Update System
Summary

==================================================
